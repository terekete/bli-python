from setuptools import setup, find_packages

# Read the long description from README.md
try:
    with open("README.md", "r", encoding="utf-8") as fh:
        long_description = fh.read()
except FileNotFoundError:
    long_description = "BLI CLI - A Pulumi-based Infrastructure Management Tool"

setup(
    name="bli",
    version="0.1.0",
    
    # Metadata
    author="terekete",
    author_email="gates.mark@gmail.com",
    description="BLI CLI - A Pulumi-based Infrastructure Management Tool",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/bli",
    
    # Packaging
    packages=find_packages(),
    
    # Python version and platform support
    python_requires='>=3.7,<4.0',
    
    # Dependencies
    install_requires=[
        "pulumi>=3.0.0,<4.0.0",
        "jinja2>=3.0.0,<4.0.0",
        "colorama>=0.4.4,<1.0.0",
    ],
    
    # Optional dependencies (extras)
    extras_require={
        'dev': [
            'pytest>=6.2.0',
            'tox>=3.24.0',
            'mypy>=0.910',
            'black>=21.5b2',
        ],
        'docs': [
            'sphinx>=4.0.0',
            'sphinx-rtd-theme>=0.5.2',
        ],
    },
    
    # Entry points for CLI
    entry_points={
        "console_scripts": [
            "bli=bli.cli:main",
        ],
    },
    
    # Metadata for PyPI
    classifiers=[
        # Development Status
        "Development Status :: 3 - Alpha",
        
        # Intended Audience
        "Intended Audience :: Developers",
        "Intended Audience :: System Administrators",
        
        # License
        "License :: OSI Approved :: MIT License",
        
        # Operating System
        "Operating System :: OS Independent",
        
        # Python Versions
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        
        # Categories
        "Topic :: Software Development :: Build Tools",
        "Topic :: System :: Systems Administration",
        "Topic :: Utilities",
    ],
    
    # Package data (include non-Python files)
    package_data={
        "bli": ["*.yaml", "*.yml"],
    },
    
    # Keyword tags for discoverability
    keywords="infrastructure pulumi cli devops deployment automation gcp",
)"""
Command modules for the BLI CLI
"""import os
import subprocess
import sys
from pathlib import Path

import colorama
from colorama import Fore, Style

class Config:
    """Configuration class for BLI CLI."""
    
    def __init__(
        self,
        stack_name: str,
        project_id: str,
        proxy_address: str,
        proxy_port: str,
        use_local_auth: bool,
        no_proxy: bool,
        project_type: str,
    ):
        self.proxy_address = proxy_address
        self.proxy_port = proxy_port
        self.project_id = project_id
        self.stack_name = stack_name
        self.use_local_auth = use_local_auth
        self.no_proxy = no_proxy
        self.project_type = project_type

    @classmethod
    def from_cli(
        cls,
        stack_name: str,
        project_id: str,
        proxy_address: str,
        proxy_port: str,
        use_local_auth: bool,
        no_proxy: bool,
        staging: bool,
        service: bool,
    ) -> 'Config':
        """Create Config instance from CLI arguments."""
        if staging and service:
            raise ValueError("Cannot specify both --stg and --srv flags")
        
        project_type = "bi-stg"
        if staging:
            project_type = "bi-stg"
        elif service:
            project_type = "bi-srv"
        
        return cls(
            stack_name=stack_name,
            project_id=project_id,
            proxy_address=proxy_address,
            proxy_port=proxy_port,
            use_local_auth=use_local_auth,
            no_proxy=no_proxy,
            project_type=project_type,
        )

def get_stack_name(provided_name: str, work_dir: Path) -> str:
    """Get stack name from provided name or default."""
    if provided_name:
        return provided_name
    
    if (work_dir / "Pulumi.yaml").exists():
        return "bli-stack"
    
    print("Stack name is required. Please provide it using the -s flag.")
    sys.exit(1)

def setup_proxy(config: Config) -> None:
    """Set up HTTP proxy configuration."""
    if config.no_proxy:
        print(f"{Fore.YELLOW}Skipping proxy setup{Style.RESET_ALL}")
        return

    print(f"{Fore.GREEN}Setting Proxy using http://{config.proxy_address}:{config.proxy_port}{Style.RESET_ALL}")

    # Set environment variables
    os.environ["HTTP_PROXY"] = f"http://{config.proxy_address}:{config.proxy_port}"
    os.environ["HTTPS_PROXY"] = f"http://{config.proxy_address}:{config.proxy_port}"

    # Configure gcloud
    subprocess.run(["gcloud", "config", "set", "proxy/type", "http"], check=True)
    subprocess.run(["gcloud", "config", "set", "proxy/address", config.proxy_address], check=True)
    subprocess.run(["gcloud", "config", "set", "proxy/port", config.proxy_port], check=True)

def setup_gcloud(config: Config) -> None:
    """Set up Google Cloud authentication."""
    if config.use_local_auth:
        print(f"{Fore.GREEN}Using local authentication{Style.RESET_ALL}")
        return

    print(f"{Fore.GREEN}Setting up Google Cloud authentication{Style.RESET_ALL}")

    home_dir = Path.home()
    credentials_path = home_dir / ".config/gcloud/application_default_credentials.json"
    
    if credentials_path.exists():
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = str(credentials_path)
    else:
        print(f"{Fore.RED}Local credentials not found. Run 'gcloud auth application-default login' first.{Style.RESET_ALL}")
        sys.exit(1)

    subprocess.run(["gcloud", "config", "set", "project", config.project_id], check=True)import os
import re
from pathlib import Path

import jinja2
from colorama import Fore, Style

from bli.utils.config import Config

def render_template(template_path: Path, output_path: Path, config: Config, verbose: bool = False) -> None:
    """Render a Jinja2 template with configuration and process Pulumi variable references.
    
    Args:
        template_path: Path to the template file
        output_path: Path where the rendered file should be saved
        config: Configuration object with values for substitution
        verbose: If True, print detailed debug information
    """
    template_content = template_path.read_text()
    
    # Create Jinja2 environment with trim_blocks and lstrip_blocks
    env = jinja2.Environment(
        trim_blocks=True,    # Remove first newline after a block
        lstrip_blocks=True,  # Strip tabs and spaces from the beginning of a line to the start of a block
        keep_trailing_newline=True  # Keep the trailing newline when rendering templates
    )
    template = env.from_string(template_content)
    
    # Prepare context
    context = {
        "VAR": dict(os.environ),
        "environment": "dev",
        "env": "dev",
        "project_type": config.project_type,
        "project": config.project_id,  # Add the project ID from config
        "location": "northamerica-northeast1",   # Add location from config
    }
    
    # Render template with Jinja2
    rendered = template.render(**context)
    
    # Process Pulumi variable references like ${project}
    # This replaces ${variable} with the actual value if it exists in our context
    def replace_var(match):
        var_name = match.group(1)
        if var_name in context:
            return str(context[var_name])
        return match.group(0)  # Keep as is if not found
    
    # Replace ${var} references with actual values
    rendered = re.sub(r'\$\{(\w+)\}', replace_var, rendered)
    
    # Remove consecutive empty lines to clean up the output
    rendered = re.sub(r'\n\s*\n\s*\n+', '\n\n', rendered)
    
    # Print debug information only in verbose mode
    if verbose:
        print("\n" + "="*80)
        print(f"{Fore.GREEN}â–¶ STARTING TEMPLATE RENDERING PROCESS{Style.RESET_ALL}")
        print("="*80 + "\n")

        print(f"{Fore.BLUE}ðŸ“„ TEMPLATE SOURCE:{Style.RESET_ALL}")
        print("â”€"*50)
        print(template_content)
        print("â”€"*50 + "\n")

        print(f"{Fore.BLUE}ðŸ”§ ENVIRONMENT VARIABLES:{Style.RESET_ALL}")
        print("â”€"*50)
        print(f"  Project Type: {config.project_type}")
        print(f"  Project ID:   {config.project_id}")
        print(f"  Location:     northamerica-northeast1")
        print(f"  Environment:  dev")
        print("â”€"*50 + "\n")

        print(f"{Fore.BLUE}ðŸ”„ RENDERED OUTPUT:{Style.RESET_ALL}")
        print("â”€"*50)
        print(rendered)
        print("â”€"*50 + "\n")

        print("="*80)
        print(f"{Fore.GREEN}âœ“ TEMPLATE RENDERING COMPLETE{Style.RESET_ALL}")
        print("="*80 + "\n")
    else:
        # Just print a simple message in non-verbose mode
        print(f"{Fore.GREEN}Rendered template: {template_path.name} â†’ {output_path.name}{Style.RESET_ALL}")

    # Write output
    output_path.write_text(rendered)"""
Utility modules for the BLI CLI
"""import os
import re
import subprocess
from pathlib import Path
from typing import List, Callable, Optional

from colorama import Fore, Style

def colorize_pulumi_output(output: str) -> str:
    """Add colors to Pulumi output for better readability."""
    # Define color patterns
    patterns = [
        # Resource changes
        (r'(\s+\+\s+)([^\s].*?)(create)', f'\\1{Fore.GREEN}\\2{Style.RESET_ALL}{Fore.GREEN}\\3{Style.RESET_ALL}'),
        (r'(\s+\-\s+)([^\s].*?)(delete)', f'\\1{Fore.RED}\\2{Style.RESET_ALL}{Fore.RED}\\3{Style.RESET_ALL}'),
        (r'(\s+~\s+)([^\s].*?)(update)', f'\\1{Fore.YELLOW}\\2{Style.RESET_ALL}{Fore.YELLOW}\\3{Style.RESET_ALL}'),
        
        # Section headers
        (r'^(Previewing update|Updating|Destroying|Refreshing) \((.*?)\):', 
         f'{Fore.CYAN}\\1{Style.RESET_ALL} ({Fore.MAGENTA}\\2{Style.RESET_ALL}):'),
        (r'^(Outputs:)', f'{Fore.BLUE}\\1{Style.RESET_ALL}'),
        (r'^(Resources:)', f'{Fore.BLUE}\\1{Style.RESET_ALL}'),
        
        # Resource counts
        (r'(\d+) to create', f'{Fore.GREEN}\\1{Style.RESET_ALL} to create'),
        (r'(\d+) to delete', f'{Fore.RED}\\1{Style.RESET_ALL} to delete'),
        (r'(\d+) to update', f'{Fore.YELLOW}\\1{Style.RESET_ALL} to update'),
        (r'(\d+) changes', f'{Fore.CYAN}\\1{Style.RESET_ALL} changes'),
        
        # Final summary
        (r'(Preview|Update|Destroy|Refresh) completed', f'{Fore.GREEN}\\1 completed{Style.RESET_ALL}'),
        (r'(create:\s+)(\d+)', f'\\1{Fore.GREEN}\\2{Style.RESET_ALL}'),
        (r'(delete:\s+)(\d+)', f'\\1{Fore.RED}\\2{Style.RESET_ALL}'),
        (r'(update:\s+)(\d+)', f'\\1{Fore.YELLOW}\\2{Style.RESET_ALL}'),
        (r'(same:\s+)(\d+)', f'\\1{Fore.BLUE}\\2{Style.RESET_ALL}'),
        
        # Error messages
        (r'(\*\*.*?failed\*\*)', f'{Fore.RED}\\1{Style.RESET_ALL}'),
        (r'(error:.*)', f'{Fore.RED}\\1{Style.RESET_ALL}'),
        (r'(warning:.*)', f'{Fore.YELLOW}\\1{Style.RESET_ALL}'),
        
        # Stack messages
        (r"(Stack '.*?') (not found\. Creating new stack\.\.\.)", 
         f"{Fore.MAGENTA}\\1{Style.RESET_ALL} {Fore.YELLOW}\\2{Style.RESET_ALL}"),
    ]
    
    # Apply all color patterns
    colored_output = output
    for pattern, replacement in patterns:
        colored_output = re.sub(pattern, replacement, colored_output, flags=re.MULTILINE)
    
    return colored_output

def run_pulumi_command(
    command: List[str], 
    cwd: str, 
    on_output: Optional[Callable[[str], None]] = None,
    suppress_output: bool = False,
    filter_output: Optional[Callable[[str], bool]] = None
) -> str:
    """Run a Pulumi command and colorize its output.
    
    Args:
        command: The command to run as a list of strings
        cwd: The working directory to run the command in
        on_output: Optional callback function that receives each line of output
        suppress_output: If True, don't print any output to console
        filter_output: Optional function to filter output lines (return True to print)
        
    Returns:
        The complete command output as a string
    """
    # Set PULUMI_CONFIG_PASSPHRASE environment variable to empty string
    env = os.environ.copy()
    env["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    process = subprocess.Popen(
        command,
        cwd=cwd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,  # Line buffered
        env=env     # Pass the modified environment
    )
    
    output_lines = []
    for line in iter(process.stdout.readline, ''):
        # Store the original line for return value
        output_lines.append(line)
        
        # Apply filtering if provided
        if filter_output and not filter_output(line):
            continue
            
        # Colorize the line
        colored_line = colorize_pulumi_output(line.rstrip())
        
        # Print the colorized line if not suppressed
        if not suppress_output:
            print(colored_line)
        
        # Call the on_output callback if provided
        if on_output:
            on_output(line)
    
    # Wait for the process to complete
    process.stdout.close()
    return_code = process.wait()
    
    # Return the complete output
    output = ''.join(output_lines)
    
    if return_code != 0:
        # Don't raise exception for certain known errors in specific commands
        if "refresh" in command and ("not found" in output or "notFound" in output):
            # For refresh commands, don't fail on missing resources
            return output
        if "The specified bucket does not exist" in output:
            # Special case for missing buckets
            return output
            
        raise subprocess.CalledProcessError(return_code, command, output)
    
    return output

def fix_state_for_missing_resources(workspace_dir: str, stack_name: str, verbose: bool = False) -> bool:
    """Fix Pulumi state when resources are missing in the cloud but exist in state.
    
    Args:
        workspace_dir: The directory containing the Pulumi project
        stack_name: Name of the stack to fix
        verbose: If True, print detailed information
        
    Returns:
        bool: True if state was fixed successfully, False otherwise
    """
    import json
    import tempfile
    
    try:
        if verbose:
            print(f"{Fore.CYAN}Attempting to fix state for missing resources{Style.RESET_ALL}")
        
        # Export the current state
        state_json = run_pulumi_command(
            ["pulumi", "stack", "export", "--stack", stack_name],
            workspace_dir,
            suppress_output=True
        )
        
        if not state_json:
            print(f"{Fore.YELLOW}Warning: No state found to fix{Style.RESET_ALL}")
            return False
        
        # Parse the state
        try:
            state = json.loads(state_json)
        except json.JSONDecodeError:
            print(f"{Fore.YELLOW}Warning: Could not parse state JSON{Style.RESET_ALL}")
            return False
        
        # Check if there are resources to fix
        if 'resources' not in state or not state['resources']:
            if verbose:
                print(f"{Fore.YELLOW}No resources found in state{Style.RESET_ALL}")
            return False
        
        # Identify and remove resources that might be causing 404 errors
        original_count = len(state['resources'])
        
        # Look for resources with URNs containing known problematic resources
        # Add patterns for additional resources as needed
        problematic_patterns = ['my-bucket', 'no-longer-exists']
        
        # Filter out problematic resources
        state['resources'] = [
            r for r in state['resources']
            if not any(pattern in r.get('urn', '') for pattern in problematic_patterns)
        ]
        
        # Check if we removed any resources
        removed_count = original_count - len(state['resources'])
        if removed_count == 0:
            if verbose:
                print(f"{Fore.YELLOW}No problematic resources found in state{Style.RESET_ALL}")
            return False
        
        print(f"{Fore.GREEN}Identified {removed_count} problematic resources to remove from state{Style.RESET_ALL}")
        
        # Write the modified state to a temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as temp_file:
            json.dump(state, temp_file)
            temp_path = temp_file.name
        
        # Import the fixed state
        run_pulumi_command(
            ["pulumi", "stack", "import", "--file", temp_path, "--stack", stack_name],
            workspace_dir,
            suppress_output=not verbose
        )
        
        # Clean up the temporary file
        Path(temp_path).unlink(missing_ok=True)
        
        print(f"{Fore.GREEN}Successfully fixed state by removing {removed_count} problematic resources{Style.RESET_ALL}")
        return True
        
    except Exception as e:
        print(f"{Fore.RED}Error fixing state: {str(e)}{Style.RESET_ALL}")
        return Falseimport os
import subprocess
import sys
from shutil import which

import colorama
from colorama import Fore, Style

def check_dependencies(quiet: bool = False) -> bool:
    """
    Check if required dependencies are installed.
    
    Args:
        quiet: If True, don't print confirmation messages for installed dependencies
    
    Returns:
        bool: True if all dependencies are installed, False otherwise
    """
    if not quiet:
        print("Checking dependencies...")
    
    # Check for Pulumi first
    pulumi_found = False
    if which("pulumi"):
        try:
            result = subprocess.run(["pulumi", "version"], check=False, capture_output=True, text=True)
            if result.returncode == 0:
                pulumi_found = True
                if not quiet:
                    print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Pulumi CLI is installed")
            else:
                # Try another command to verify Pulumi is working
                about_result = subprocess.run(["pulumi", "about"], check=False, capture_output=True, text=True)
                if about_result.returncode == 0:
                    pulumi_found = True
                    if not quiet:
                        print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Pulumi CLI is installed")
        except Exception:
            pulumi_found = False
    
    if not pulumi_found:
        if not quiet:
            print(f"{Fore.RED}âœ—{Style.RESET_ALL} Pulumi CLI is not installed.")
            print(f"Please run 'bli init' to set up your environment.")
        return False
    
    # Check other dependencies
    gcloud_found = False
    if which("gcloud"):
        try:
            result = subprocess.run(["gcloud", "version"], check=False, capture_output=True, text=True)
            if result.returncode == 0:
                gcloud_found = True
                if not quiet:
                    print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Google Cloud SDK is installed")
        except Exception:
            gcloud_found = False
    
    if not gcloud_found:
        if not quiet:
            print(f"{Fore.RED}âœ—{Style.RESET_ALL} Google Cloud SDK is not installed.")
            print(f"Please run 'bli init' to set up your environment.")
        return False
    
    return True

def install_dependencies() -> bool:
    """
    Install all required dependencies for BLI.
    This is intended to be called by the 'init' command.
    
    Returns:
        bool: True if all dependencies were installed successfully, False otherwise
    """
    print("Setting up BLI environment...")
    
    # Install Pulumi
    pulumi_installed = install_pulumi()
    if not pulumi_installed:
        return False
    
    # Check Google Cloud SDK
    gcloud_found = False
    if which("gcloud"):
        try:
            result = subprocess.run(["gcloud", "version"], check=False, capture_output=True, text=True)
            if result.returncode == 0:
                gcloud_found = True
                print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Google Cloud SDK is installed")
        except Exception:
            gcloud_found = False
    
    if not gcloud_found:
        print(f"{Fore.RED}âœ—{Style.RESET_ALL} Google Cloud SDK is not installed.")
        print("Installing Google Cloud SDK...")
        
        try:
            if sys.platform.startswith('linux') or sys.platform == 'darwin':
                # Instructions for Linux/macOS installation
                print(f"{Fore.YELLOW}Please install Google Cloud SDK manually by following the instructions at:{Style.RESET_ALL}")
                print("https://cloud.google.com/sdk/docs/install")
                return False
            elif sys.platform == 'win32':
                # Instructions for Windows installation
                print(f"{Fore.YELLOW}Please install Google Cloud SDK manually by following the instructions at:{Style.RESET_ALL}")
                print("https://cloud.google.com/sdk/docs/install")
                return False
        except Exception as e:
            print(f"{Fore.RED}Failed to install Google Cloud SDK: {str(e)}{Style.RESET_ALL}")
            return False
    
    print(f"{Fore.GREEN}All dependencies are installed successfully!{Style.RESET_ALL}")
    return True

def install_pulumi() -> bool:
    """Install Pulumi CLI if not already installed."""
    # First check if Pulumi is available in PATH
    if which("pulumi"):
        # Check if it works properly
        try:
            result = subprocess.run(["pulumi", "version"], check=False, capture_output=True, text=True)
            if result.returncode == 0:
                print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Pulumi CLI is already installed")
                return True
            else:
                # Try another command to verify Pulumi is working
                about_result = subprocess.run(["pulumi", "about"], check=False, capture_output=True, text=True)
                if about_result.returncode == 0:
                    print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Pulumi CLI is already installed")
                    return True
                print(f"{Fore.YELLOW}Pulumi found but version check failed: {result.stderr.strip() if result.stderr else 'Unknown error'}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.YELLOW}Pulumi found but encountered an error: {str(e)}{Style.RESET_ALL}")
    else:
        print("Pulumi CLI not found in PATH.")
        
    # If we get here, we need to install Pulumi
    print("Installing Pulumi CLI...")
    
    try:
        if sys.platform.startswith('linux'):
            subprocess.run(["curl", "-fsSL", "https://get.pulumi.com", "|", "sh"], check=True, shell=True)
            # Add to PATH for the current session
            pulumi_bin_path = os.path.expanduser("~/.pulumi/bin")
            if os.path.exists(pulumi_bin_path):
                os.environ["PATH"] = f"{pulumi_bin_path}:{os.environ.get('PATH', '')}"
                
        elif sys.platform == 'darwin':
            # Check if Homebrew is available
            if which("brew"):
                subprocess.run(["brew", "install", "pulumi"], check=True)
            else:
                subprocess.run(["curl", "-fsSL", "https://get.pulumi.com", "|", "sh"], check=True, shell=True)
                # Add to PATH for the current session
                pulumi_bin_path = os.path.expanduser("~/.pulumi/bin")
                if os.path.exists(pulumi_bin_path):
                    os.environ["PATH"] = f"{pulumi_bin_path}:{os.environ.get('PATH', '')}"
                    
        elif sys.platform == 'win32':
            if which("choco"):
                subprocess.run(["choco", "install", "pulumi", "-y"], check=True, shell=True)
            else:
                # PowerShell installer as fallback
                ps_cmd = "(New-Object System.Net.WebClient).DownloadString('https://get.pulumi.com/install.ps1') | powershell -Command -"
                subprocess.run(["powershell", "-Command", ps_cmd], check=True)
                # Add to PATH for current session
                pulumi_bin_path = os.path.join(os.environ.get('USERPROFILE', ''), '.pulumi', 'bin')
                if os.path.exists(pulumi_bin_path):
                    os.environ["PATH"] = f"{pulumi_bin_path};{os.environ.get('PATH', '')}"
        else:
            print(f"{Fore.RED}Unsupported platform: {sys.platform}{Style.RESET_ALL}")
            return False
        
        # Verify installation with a simple command
        if which("pulumi"):
            verify_result = subprocess.run(["pulumi", "about"], check=False, capture_output=True, text=True)
            if verify_result.returncode == 0:
                print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Pulumi CLI installed successfully")
                return True
            else:
                print(f"{Fore.RED}Pulumi installation verification failed.{Style.RESET_ALL}")
                if verify_result.stderr:
                    print(f"Error: {verify_result.stderr.strip()}")
                return False
        else:
            print(f"{Fore.RED}Pulumi installation completed but CLI not found in PATH.{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}You may need to restart your terminal or add Pulumi to your PATH manually.{Style.RESET_ALL}")
            return False
            
    except subprocess.SubprocessError as e:
        print(f"{Fore.RED}Failed to install Pulumi CLI: {str(e)}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Please install Pulumi manually from https://www.pulumi.com/docs/get-started/install/{Style.RESET_ALL}")
        return False#!/usr/bin/env python3
import argparse
import os
import sys
from pathlib import Path
from io import StringIO

import colorama
from colorama import Fore, Style

from bli.commands.clear import clear_command
from bli.commands.deploy import deploy_command
from bli.commands.destroy import destroy_command
from bli.commands.init import init_command
from bli.commands.preview import preview_command
from bli.commands.graph import graph_command
from bli.utils import dependencies

# Initialize colorama
colorama.init()

ASCII_ART = """
BLI Command Line
"""

# Custom argument parser that provides colorized help output
class BLIArgumentParser(argparse.ArgumentParser):
    def error(self, message):
        """Print a cleaner error message for missing arguments"""
        # Print the ASCII art first
        print(f"{Fore.MAGENTA}{ASCII_ART}{Style.RESET_ALL}")
        
        command = os.path.basename(sys.argv[0])
        
        if "required" in message:
            # Customize the "required argument" message
            print(f"{Fore.RED}Error: Missing required arguments{Style.RESET_ALL}")
            print(f"\nTo see usage information, run: {Fore.CYAN}{self.prog} --help{Style.RESET_ALL}\n")
        else:
            # For other errors, use a cleaner format but keep the original message
            print(f"{Fore.RED}Error: {message}{Style.RESET_ALL}")
            print(f"\nTo see usage information, run: {Fore.CYAN}{self.prog} --help{Style.RESET_ALL}\n")
        
        sys.exit(1)
    
    def print_help(self, file=None):
        """Override print_help to colorize the output"""
        # Capture the standard help output
        help_io = StringIO()
        super().print_help(help_io)
        help_text = help_io.getvalue()
        
        # Colorize different parts of the help text
        lines = help_text.split('\n')
        colorized_lines = []
        
        for line in lines:
            if line.startswith('usage:'):
                # Colorize usage line
                parts = line.split(' ', 1)
                if len(parts) > 1:
                    colorized_lines.append(f"{Fore.YELLOW}{parts[0]}{Style.RESET_ALL} {parts[1]}")
                else:
                    colorized_lines.append(f"{Fore.YELLOW}{line}{Style.RESET_ALL}")
            elif ':' in line and line[0] != ' ':
                # Colorize section headers (positional arguments, optional arguments)
                colorized_lines.append(f"{Fore.GREEN}{line}{Style.RESET_ALL}")
            elif line.strip().startswith('-'):
                # Colorize argument flags
                parts = line.split('  ', 1)
                if len(parts) > 1:
                    indent = ' ' * (len(line) - len(line.lstrip()))
                    flags = parts[0].strip()
                    desc = parts[1]
                    
                    # Check if this is a required argument
                    if "(required)" in desc:
                        desc_colored = desc.replace("(required)", f"{Fore.RED}(required){Style.RESET_ALL}")
                        colorized_lines.append(f"{indent}{Fore.CYAN}{flags}{Style.RESET_ALL}  {desc_colored}")
                    else:
                        colorized_lines.append(f"{indent}{Fore.CYAN}{flags}{Style.RESET_ALL}  {desc}")
                else:
                    colorized_lines.append(line)
            elif line.startswith('Example:'):
                # Colorize examples
                parts = line.split(':', 1)
                if len(parts) > 1:
                    colorized_lines.append(f"{Fore.MAGENTA}{parts[0]}:{Style.RESET_ALL}{parts[1]}")
                else:
                    colorized_lines.append(line)
            else:
                # Leave other lines unchanged
                colorized_lines.append(line)
        
        # Print the colorized help text
        print('\n'.join(colorized_lines), file=file or sys.stdout)

class BLIHelpFormatter(argparse.RawDescriptionHelpFormatter):
    """Custom help formatter to tweak the help output appearance"""
    def __init__(self, prog):
        super().__init__(prog, max_help_position=35, width=100)

def depend_command(args: argparse.Namespace) -> None:
    """Execute the depend command to check and install dependencies."""
    if args.check_only:
        # Only check dependencies without installing
        if dependencies.check_dependencies(quiet=False):
            print(f"{Fore.GREEN}All required dependencies are installed and working correctly.{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}Some dependencies are missing. Run 'bli depend' without --check-only to install them.{Style.RESET_ALL}")
            sys.exit(1)
    else:
        # Check and install dependencies
        if not dependencies.install_dependencies():
            print(f"{Fore.RED}Failed to install all required dependencies.{Style.RESET_ALL}")
            sys.exit(1)
        print(f"{Fore.GREEN}All dependencies are installed and ready to use.{Style.RESET_ALL}")

def main() -> None:
    """Main function for the BLI CLI."""
    # Set up environment
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Set up argument parser with custom error handling
    parser = BLIArgumentParser(
        description=f"{Fore.BLUE}Bare Layer Infrastructure CLI - A wrapper for Pulumi to manage GCP infrastructure{Style.RESET_ALL}",
        epilog=f"{Fore.BLUE}For more information, visit https://github.com/yourusername/bli{Style.RESET_ALL}",
        formatter_class=BLIHelpFormatter
    )
    subparsers = parser.add_subparsers(dest="command", help="Command to execute")
    
    # Deploy command
    deploy_parser = subparsers.add_parser(
        "deploy", 
        help="Deploy infrastructure",
        description=f"{Fore.BLUE}Deploy your infrastructure using Pulumi. This will create or update resources as defined in your Pulumi project.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli deploy -s my-stack -i my-gcp-project",
        formatter_class=BLIHelpFormatter
    )
    deploy_parser.add_argument("-s", "--stack-name", help="Stack name to deploy")
    deploy_parser.add_argument("-i", "--project-id", required=True, help="GCP Project ID (required)")
    deploy_parser.add_argument("-r", "--proxy-address", default="proxy.telus.com", help="Proxy address (default: proxy.telus.com)")
    deploy_parser.add_argument("-o", "--proxy-port", default="8080", help="Proxy port (default: 8080)")
    deploy_parser.add_argument("-l", "--use-local-auth", action="store_true", help="Use local authentication")
    deploy_parser.add_argument("-n", "--no-proxy", action="store_true", help="Skip proxy setup")
    deploy_parser.add_argument("-w", "--work-dir", type=Path, default=Path("."), help="Working directory (default: current directory)")
    deploy_parser.add_argument("--stg", action="store_true", help="Use staging environment")
    deploy_parser.add_argument("--srv", action="store_true", help="Use service environment")
    deploy_parser.add_argument("-v", "--verbose", action="store_true", help="Show verbose output including template details")
    
    # Preview command
    preview_parser = subparsers.add_parser(
        "preview", 
        help="Preview infrastructure changes",
        description=f"{Fore.BLUE}Preview changes to your infrastructure without deploying. Shows what would be created, updated, or deleted.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli preview -s my-stack -i my-gcp-project",
        formatter_class=BLIHelpFormatter
    )
    preview_parser.add_argument("-s", "--stack-name", help="Stack name to preview")
    preview_parser.add_argument("-i", "--project-id", required=True, help="GCP Project ID (required)")
    preview_parser.add_argument("-r", "--proxy-address", default="proxy.telus.com", help="Proxy address (default: proxy.telus.com)")
    preview_parser.add_argument("-o", "--proxy-port", default="8080", help="Proxy port (default: 8080)")
    preview_parser.add_argument("-l", "--use-local-auth", action="store_true", help="Use local authentication")
    preview_parser.add_argument("-n", "--no-proxy", action="store_true", help="Skip proxy setup")
    preview_parser.add_argument("-w", "--work-dir", type=Path, default=Path("."), help="Working directory (default: current directory)")
    preview_parser.add_argument("--stg", action="store_true", help="Use staging environment")
    preview_parser.add_argument("--srv", action="store_true", help="Use service environment")
    preview_parser.add_argument("-v", "--verbose", action="store_true", help="Show verbose output including template details")
    
    # Init command
    init_parser = subparsers.add_parser(
        "init", 
        help="Initialize a new stack",
        description=f"{Fore.BLUE}Initialize a new Pulumi stack with YAML configuration. This creates the necessary Pulumi project files and configures a local stack.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli init -s dev-stack -w ./my_infrastructure",
        formatter_class=BLIHelpFormatter
    )
    init_parser.add_argument(
        "-s", "--stack-name", 
        required=True, 
        help="Name of the stack to create (required)"
    )
    init_parser.add_argument(
        "-w", "--work-dir", 
        type=Path, 
        default=Path("."), 
        help="Working directory for the stack (defaults to current directory)"
    )
    
    # Destroy command
    destroy_parser = subparsers.add_parser(
        "destroy", 
        help="Destroy infrastructure",
        description=f"{Fore.BLUE}Destroy all resources in the specified stack. This will permanently remove all managed resources.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli destroy -s my-stack -i my-gcp-project",
        formatter_class=BLIHelpFormatter
    )
    destroy_parser.add_argument("-s", "--stack-name", help="Stack name to destroy")
    destroy_parser.add_argument("-i", "--project-id", required=True, help="GCP Project ID (required)")
    destroy_parser.add_argument("-r", "--proxy-address", default="proxy.telus.com", help="Proxy address (default: proxy.telus.com)")
    destroy_parser.add_argument("-o", "--proxy-port", default="8080", help="Proxy port (default: 8080)")
    destroy_parser.add_argument("-l", "--use-local-auth", action="store_true", help="Use local authentication")
    destroy_parser.add_argument("-n", "--no-proxy", action="store_true", help="Skip proxy setup")
    destroy_parser.add_argument("-w", "--work-dir", type=Path, default=Path("."), help="Working directory (default: current directory)")
    destroy_parser.add_argument("--stg", action="store_true", help="Use staging environment")
    destroy_parser.add_argument("--srv", action="store_true", help="Use service environment")
    destroy_parser.add_argument("-v", "--verbose", action="store_true", help="Show verbose output including template details")
    
    # Clear command
    clear_parser = subparsers.add_parser(
        "clear", 
        help="Clear Pulumi lock files",
        description=f"{Fore.BLUE}Clear Pulumi lock files when operations get stuck. Useful for resolving 'stack is already being updated' errors.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli clear -s my-stack -w ./my_infrastructure",
        formatter_class=BLIHelpFormatter
    )
    clear_parser.add_argument("-w", "--work-dir", type=Path, default=Path("."), help="Working directory (default: current directory)")
    clear_parser.add_argument("-s", "--stack-name", help="Stack name for which to clear locks")
    
    # Depend command
    depend_parser = subparsers.add_parser(
        "depend", 
        help="Check and install dependencies",
        description=f"{Fore.BLUE}Check for required dependencies (Pulumi, GCP CLI) and install them if missing.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli depend --check-only",
        formatter_class=BLIHelpFormatter
    )
    depend_parser.add_argument("--check-only", action="store_true", help="Only check dependencies without installing")
    
    # Graph command
    graph_parser = subparsers.add_parser(
        "graph", 
        help="Generate dependency graph for infrastructure",
        description=f"{Fore.BLUE}Generate a visual representation of your infrastructure resources and their dependencies using Pulumi's graph capabilities.{Style.RESET_ALL}",
        epilog=f"{Fore.MAGENTA}Example:{Style.RESET_ALL} bli graph -s my-stack -i my-gcp-project -t -d",
        formatter_class=BLIHelpFormatter
    )
    graph_parser.add_argument("-s", "--stack-name", help="Stack name to graph")
    graph_parser.add_argument("-i", "--project-id", required=True, help="GCP Project ID (required)")
    graph_parser.add_argument("-r", "--proxy-address", default="proxy.telus.com", help="Proxy address (default: proxy.telus.com)")
    graph_parser.add_argument("-p", "--proxy-port", default="8080", help="Proxy port (default: 8080)")  # Changed from -o to -p
    graph_parser.add_argument("-l", "--use-local-auth", action="store_true", help="Use local authentication")
    graph_parser.add_argument("-n", "--no-proxy", action="store_true", help="Skip proxy setup")
    graph_parser.add_argument("-w", "--work-dir", type=Path, default=Path("."), help="Working directory (default: current directory)")
    graph_parser.add_argument("--stg", action="store_true", help="Use staging environment")
    graph_parser.add_argument("--srv", action="store_true", help="Use service environment")
    graph_parser.add_argument("-v", "--verbose", action="store_true", help="Show verbose output including template details")
    graph_parser.add_argument("-f", "--format", default="dot", choices=["dot", "json", "yaml"], help="Graph output format (default: dot)")
    graph_parser.add_argument("--output", help="Save graph to file instead of printing to console")
    graph_parser.add_argument("-t", "--tree", action="store_true", help="Display graph as a console-friendly tree view")
    graph_parser.add_argument("-d", "--details", action="store_true", help="Show detailed resource information in the tree view")
    graph_parser.add_argument("--pretty", action="store_true", help="Format the graph output in a readable text format")

    # Parse arguments
    args = parser.parse_args()
    
    # Print ASCII art (only if we didn't error out in argument parsing)
    print(f"{Fore.MAGENTA}{ASCII_ART}{Style.RESET_ALL}")
    
    # Execute command
    try:
        if args.command == "init":
            # For init command, install all dependencies
            if not dependencies.install_dependencies():
                sys.exit(1)
            init_command(args)
        elif args.command == "depend":
            # Handle dependency management
            depend_command(args)
        elif args.command is None:
            # No command provided, show help
            parser.print_help()
            sys.exit(1)
        else:
            # For all other commands, just check dependencies
            if not dependencies.check_dependencies(quiet=False):
                print(f"{Fore.YELLOW}Some dependencies are missing. Run 'bli depend' to install them.{Style.RESET_ALL}")
                sys.exit(1)
                
            # Execute the appropriate command
            if args.command == "deploy":
                deploy_command(args)
            elif args.command == "preview":
                preview_command(args)
            elif args.command == "destroy":
                destroy_command(args)
            elif args.command == "clear":
                clear_command(args)
            elif args.command == "graph":
                graph_command(args)
            else:
                parser.print_help()
                sys.exit(1)
    except Exception as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()from argparse import Namespace
from pathlib import Path
import os
import re
import shutil
import subprocess
from typing import Optional

from colorama import Fore, Style

from bli.utils.config import Config, get_stack_name, setup_gcloud, setup_proxy
from bli.utils.pulumi_utils import run_pulumi_command
from bli.utils.templating import render_template

def clear_locks_for_stack(pulumi_home: Path, stack_name: str, verbose: bool = False) -> None:
    """Clear any lock files for the given stack."""
    locks_dir = pulumi_home / "locks" / stack_name
    if locks_dir.exists():
        if verbose:
            print(f"Clearing locks for stack '{stack_name}'...")
        try:
            for lock_file in locks_dir.glob("*.json"):
                try:
                    lock_file.unlink()
                    if verbose:
                        print(f"Removed lock file: {lock_file.name}")
                except Exception as e:
                    if verbose:
                        print(f"Could not remove lock file {lock_file.name}: {str(e)}")
        except Exception as e:
            if verbose:
                print(f"Error clearing locks: {str(e)}")

def simplify_resource_error(error_output: str) -> str:
    """Convert verbose cloud provider errors into simplified, user-friendly messages."""
    
    # Bucket already exists (GCP 409 Conflict)
    if "Error 409" in error_output and "already own it" in error_output:
        return f"{Fore.YELLOW}The resource already exists and you already own it. No changes required.{Style.RESET_ALL}"
    
    # Not found errors
    if "Error 404" in error_output and "not found" in error_output:
        return f"{Fore.YELLOW}The resource doesn't exist in the cloud provider.{Style.RESET_ALL}"
        
    # Permission errors
    if "Error 403" in error_output and ("permission" in error_output.lower() or "forbidden" in error_output.lower()):
        return f"{Fore.RED}You don't have sufficient permissions to perform this operation.{Style.RESET_ALL}"
    
    # Quota exceeded
    if "quota" in error_output.lower() and "exceed" in error_output.lower():
        return f"{Fore.RED}Quota exceeded for this resource. Please check your GCP quotas.{Style.RESET_ALL}"
    
    # Filter out help text for commands
    if "Usage:" in error_output and "Flags:" in error_output:
        lines = error_output.split('\n')
        filtered_lines = []
        in_help_section = False
        
        for line in lines:
            if "Usage:" in line:
                in_help_section = True
                # Add only the error line before usage
                for i in range(len(filtered_lines)-1, -1, -1):
                    if "error:" in filtered_lines[i].lower():
                        filtered_lines = filtered_lines[:i+1]
                        break
                continue
            elif not in_help_section or "error:" in line.lower():
                filtered_lines.append(line)
        
        return '\n'.join(filtered_lines)
    
    # Generic error - truncate the verbose parts
    if "error:" in error_output:
        # Get just the core error message
        for line in error_output.split('\n'):
            if "googleapi: Error" in line:
                parts = line.split("googleapi: Error ")
                if len(parts) > 1:
                    error_code = parts[1].split(':', 1)[0]
                    error_message = parts[1].split(':', 1)[1].split(',')[0] if ':' in parts[1] else parts[1]
                    return f"{Fore.RED}GCP Error {error_code}: {error_message}{Style.RESET_ALL}"
    
    # Return original if no simplification was possible
    return error_output

def process_pulumi_directory(
    dir_path: Path,
    build_path: Path,
    config: Config,
    inner_stack: Optional[str] = None,
    is_preview: bool = True,
    verbose: bool = False,
) -> None:
    """Process a Pulumi directory for preview."""
    if verbose:
        print(f"Processing Pulumi directory in: {dir_path}")
    
    # Get absolute build path
    abs_build_path = build_path.absolute()
    
    # Create build directory
    abs_build_path.mkdir(parents=True, exist_ok=True)
    pulumi_state_path = abs_build_path / ".pulumi"
    pulumi_state_path.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables - ensure Pulumi uses the right state directory
    os.environ["PULUMI_HOME"] = str(pulumi_state_path)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Clear any locks that might exist
    clear_locks_for_stack(pulumi_state_path, config.stack_name, verbose)
    
    # Create a subprocess environment with the correct PULUMI_HOME
    env = os.environ.copy()
    
    # Copy files from dir_path to build_path
    for entry in dir_path.iterdir():
        if entry.is_file() and entry.name != "Pulumi.yaml":
            try:
                dest_path = abs_build_path / entry.name
                shutil.copy2(entry, dest_path)  # copy2 preserves metadata
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Warning copying {entry.name}: {str(e)}{Style.RESET_ALL}")
    
    # Render Pulumi.yaml if it exists
    if (dir_path / "Pulumi.yaml").exists():
        render_template(
            dir_path / "Pulumi.yaml",
            abs_build_path / "Pulumi.yaml",
            config,
            verbose
        )
    
    # Run Pulumi preview command with colorized output
    try:
        # Login to Pulumi backend
        if verbose:
            print(f"{Fore.CYAN}Logging in to Pulumi backend...{Style.RESET_ALL}")
        
        login_attempts = [
            ["pulumi", "login", "file://~", "--local"],
            ["pulumi", "login", "file://", "--local"],
            ["pulumi", "login", "file://~"],
            ["pulumi", "login", "file://"]
        ]
        
        login_success = False
        for login_cmd in login_attempts:
            try:
                result = subprocess.run(
                    login_cmd,
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    login_success = True
                    if verbose:
                        print(f"{Fore.GREEN}Login successful with command: {' '.join(login_cmd)}{Style.RESET_ALL}")
                    break
                elif verbose:
                    print(f"{Fore.YELLOW}Login attempt failed with: {' '.join(login_cmd)}{Style.RESET_ALL}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Login exception: {str(e)}{Style.RESET_ALL}")
        
        # Check if stack exists by first looking for the stack files directly
        stack_exists = False
        try:
            # Check for stack files in the state directory
            stack_dir = pulumi_state_path / "stacks" / config.stack_name
            stack_file = stack_dir / "stack.json"
            
            if stack_dir.exists() and stack_file.exists():
                stack_exists = True
                if verbose:
                    print(f"{Fore.GREEN}Found existing stack files for '{config.stack_name}' in {stack_dir}{Style.RESET_ALL}")
            
            # If stack files don't exist, try command-line check as fallback
            if not stack_exists:
                stack_ls_result = subprocess.run(
                    ["pulumi", "stack", "ls"],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                # Check if the stack name is in the output
                if stack_ls_result.returncode == 0 and config.stack_name in stack_ls_result.stdout:
                    stack_exists = True
                    if verbose:
                        print(f"{Fore.GREEN}Found stack '{config.stack_name}' in Pulumi stack list{Style.RESET_ALL}")
            
        except Exception as e:
            if verbose:
                print(f"{Fore.YELLOW}Error checking for stack: {str(e)}{Style.RESET_ALL}")
            stack_exists = False
        
        # Create or select stack
        if not stack_exists:
            print(f"{Fore.YELLOW}Stack '{config.stack_name}' not found. Creating new stack...{Style.RESET_ALL}")
            
            if not (abs_build_path / "Pulumi.yaml").exists():
                # Create new project first
                project_name = "bli-project"
                with open(abs_build_path / "Pulumi.yaml", "w") as f:
                    f.write(f"name: {project_name}\nruntime: yaml\ndescription: BLI Project\n")
                
            # Create new stack with better error handling
            stack_init_result = subprocess.run(
                ["pulumi", "stack", "init", config.stack_name, "--non-interactive"],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            if stack_init_result.returncode == 0:
                print(f"{Fore.GREEN}Created stack: {config.stack_name}{Style.RESET_ALL}")
            else:
                # Show the actual error message
                error_output = stack_init_result.stderr if stack_init_result.stderr else stack_init_result.stdout
                if verbose:
                    print(f"{Fore.YELLOW}Stack creation output: {error_output}{Style.RESET_ALL}")
                
                # Check for common error patterns
                if "already exists" in error_output:
                    print(f"{Fore.YELLOW}Stack already exists, selecting it instead{Style.RESET_ALL}")
                elif "PULUMI_ACCESS_TOKEN" in error_output:
                    print(f"{Fore.YELLOW}Login issue detected. Trying explicit login...{Style.RESET_ALL}")
                    # Try with explicit file:// login
                    subprocess.run(
                        ["pulumi", "login", "file://"],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=not verbose,
                        text=True
                    )
                    # Try stack creation again
                    subprocess.run(
                        ["pulumi", "stack", "init", config.stack_name, "--non-interactive"],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=not verbose,
                        text=True
                    )
        
        # Select stack (always do this to be safe)
        select_result = subprocess.run(
            ["pulumi", "stack", "select", config.stack_name],
            cwd=str(abs_build_path),
            env=env,
            capture_output=True,
            text=True
        )
        
        if select_result.returncode == 0:
            if verbose:
                print(f"{Fore.GREEN}Selected stack: {config.stack_name}{Style.RESET_ALL}")
        elif verbose:
            print(f"{Fore.YELLOW}Stack selection output: {select_result.stderr}{Style.RESET_ALL}")
        
        # Configure stack (suppress output)
        run_pulumi_command(
            ["pulumi", "config", "set", "gcp:project", config.project_id],
            str(abs_build_path),
            suppress_output=not verbose
        )
        run_pulumi_command(
            ["pulumi", "config", "set", "project", config.project_id],
            str(abs_build_path),
            suppress_output=not verbose
        )
        
        # Execute preview - show actual Pulumi output by default
        print(f"{Fore.CYAN}Previewing changes for stack '{config.stack_name}'...{Style.RESET_ALL}")
        
        # Use direct Pulumi command to run preview and show output
        if verbose:
            # In verbose mode, show everything directly
            preview_result = subprocess.run(
                ["pulumi", "preview", "--stack", config.stack_name],
                cwd=str(abs_build_path),
                env=env,
                capture_output=False,  # Show output directly
                text=True
            )
        else:
            # In normal mode, capture and filter output
            preview_result = subprocess.run(
                ["pulumi", "preview", "--stack", config.stack_name],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            # Print the output but simplify error messages
            if preview_result.returncode == 0:
                # On success, print the full Pulumi output
                print(preview_result.stdout)
            else:
                # On error, simplify the error message
                simplified_output = simplify_resource_error(preview_result.stdout + preview_result.stderr)
                print(simplified_output)
            
    except Exception as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        raise

def preview_command(args: Namespace) -> None:
    """Execute the preview command."""
    # Ensure paths are absolute
    abs_work_dir = args.work_dir.absolute()
    abs_build_dir = abs_work_dir / "build"
    
    # Print paths only in verbose mode
    if args.verbose:
        print(f"Using work directory: {abs_work_dir}")
        print(f"Using build directory: {abs_build_dir}")
    
    # Ensure build directory exists
    abs_build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create .pulumi directory if it doesn't exist
    pulumi_dir = abs_build_dir / ".pulumi"
    pulumi_dir.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables BEFORE any Pulumi operations
    os.environ["PULUMI_HOME"] = str(pulumi_dir)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    os.environ["PULUMI_SKIP_UPDATE_CHECK"] = "true"  # Skip update checks
    
    # Verify Pulumi home directory only in verbose mode
    if args.verbose:
        try:
            result = subprocess.run(
                ["pulumi", "about"],
                env=os.environ.copy(),
                capture_output=True,
                text=True
            )
            if "PULUMI_HOME" in result.stdout:
                home_line = [line for line in result.stdout.splitlines() if "PULUMI_HOME" in line]
                print(f"Pulumi reports: {home_line[0] if home_line else 'PULUMI_HOME not found in output'}")
                
                # Check for incorrect paths in output and warn
                if str(pulumi_dir) not in ' '.join(home_line):
                    print(f"{Fore.RED}WARNING: Pulumi not using specified home directory!{Style.RESET_ALL}")
                    print(f"Expected: {pulumi_dir}")
        except Exception as e:
            print(f"Error running diagnostic: {str(e)}")
    
    # Check for locks only in verbose mode
    if args.verbose:
        locks_dir = pulumi_dir / "locks"
        if locks_dir.exists():
            print(f"Checking for locks in: {locks_dir}")
            try:
                # Walk through all stack locks
                for stack_lock_dir in locks_dir.iterdir():
                    if stack_lock_dir.is_dir():
                        print(f"Clearing locks for stack: {stack_lock_dir.name}")
                        for lock_file in stack_lock_dir.glob("*.json"):
                            try:
                                lock_file.unlink()
                                print(f"Removed lock file: {lock_file.name}")
                            except Exception as e:
                                print(f"Could not remove lock file {lock_file.name}: {str(e)}")
            except Exception as e:
                print(f"Error cleaning lock directories: {str(e)}")
    
    # Get stack name and create config
    stack_name = get_stack_name(args.stack_name, abs_work_dir)
    config = Config.from_cli(
        stack_name=stack_name,
        project_id=args.project_id,
        proxy_address=args.proxy_address,
        proxy_port=args.proxy_port,
        use_local_auth=args.use_local_auth,
        no_proxy=args.no_proxy,
        staging=args.stg,
        service=args.srv,
    )
    
    setup_proxy(config)
    setup_gcloud(config)
    
    # For extra safety, copy any Pulumi files from work dir to build dir
    for entry in abs_work_dir.glob("Pulumi.*"):
        if entry.is_file():
            target = abs_build_dir / entry.name
            try:
                shutil.copy2(entry, target)
                if args.verbose:
                    print(f"Copied Pulumi file: {entry.name}")
            except Exception as e:
                if args.verbose:
                    print(f"Failed to copy {entry.name}: {str(e)}")
    
    # Process the directory
    process_pulumi_directory(abs_work_dir, abs_build_dir, config, None, True, args.verbose)from argparse import Namespace
from pathlib import Path
import os
import shutil
import subprocess
import json
import re
from typing import Optional, Callable, List, Dict, Any

import pulumi.automation as automation
from colorama import Fore, Style

from bli.utils.config import Config, get_stack_name, setup_gcloud, setup_proxy
from bli.utils.templating import render_template
from bli.utils.pulumi_utils import run_pulumi_command

def simplify_resource_error(error_output: str) -> str:
    """Convert verbose cloud provider errors into simplified, user-friendly messages."""
    
    # Bucket already exists (GCP 409 Conflict)
    if "Error 409" in error_output and "already own it" in error_output:
        return f"{Fore.YELLOW}The resource already exists and you already own it. No changes required.{Style.RESET_ALL}"
    
    # Not found errors
    if "Error 404" in error_output and "not found" in error_output:
        return f"{Fore.YELLOW}The resource doesn't exist in the cloud provider.{Style.RESET_ALL}"
        
    # Permission errors
    if "Error 403" in error_output and ("permission" in error_output.lower() or "forbidden" in error_output.lower()):
        return f"{Fore.RED}You don't have sufficient permissions to perform this operation.{Style.RESET_ALL}"
    
    # Quota exceeded
    if "quota" in error_output.lower() and "exceed" in error_output.lower():
        return f"{Fore.RED}Quota exceeded for this resource. Please check your GCP quotas.{Style.RESET_ALL}"
    
    # Filter out help text for commands
    if "Usage:" in error_output and "Flags:" in error_output:
        lines = error_output.split('\n')
        filtered_lines = []
        in_help_section = False
        
        for line in lines:
            if "Usage:" in line:
                in_help_section = True
                # Add only the error line before usage
                for i in range(len(filtered_lines)-1, -1, -1):
                    if "error:" in filtered_lines[i].lower():
                        filtered_lines = filtered_lines[:i+1]
                        break
                continue
            elif not in_help_section or "error:" in line.lower():
                filtered_lines.append(line)
        
        return '\n'.join(filtered_lines)
    
    # Generic error - truncate the verbose parts
    if "error:" in error_output:
        # Get just the core error message
        for line in error_output.split('\n'):
            if "googleapi: Error" in line:
                parts = line.split("googleapi: Error ")
                if len(parts) > 1:
                    error_code = parts[1].split(':', 1)[0]
                    error_message = parts[1].split(':', 1)[1].split(',')[0] if ':' in parts[1] else parts[1]
                    return f"{Fore.RED}GCP Error {error_code}: {error_message}{Style.RESET_ALL}"
    
    # Return original if no simplification was possible
    return error_output

def clear_locks_for_stack(pulumi_home: Path, stack_name: str, verbose: bool = False) -> None:
    """Clear any lock files for the given stack."""
    locks_dir = pulumi_home / "locks" / stack_name
    if locks_dir.exists():
        if verbose:
            print(f"Clearing locks for stack '{stack_name}'...")
        try:
            for lock_file in locks_dir.glob("*.json"):
                try:
                    lock_file.unlink()
                    if verbose:
                        print(f"Removed lock file: {lock_file.name}")
                except Exception as e:
                    if verbose:
                        print(f"Could not remove lock file {lock_file.name}: {str(e)}")
        except Exception as e:
            if verbose:
                print(f"Error clearing locks: {str(e)}")

def extract_failing_resources(output: str) -> List[str]:
    """Extract failing resource URNs from command output."""
    failing_urns = []
    
    # Look for URNs in error messages
    urn_pattern = r'urn:pulumi:[^:]+::[^:]+::[^:]+:[^:]+::([^:]+)'
    not_found_lines = [line for line in output.split('\n') if 
                        ('not found' in line.lower() or 
                         'does not exist' in line.lower() or 
                         'notfound' in line.lower() or 
                         'deleting failed' in line.lower())]
    
    for line in not_found_lines:
        urn_matches = re.findall(urn_pattern, line)
        if urn_matches:
            for match in urn_matches:
                full_urn = line[line.find('urn:pulumi'):].split()[0].rstrip(':,')
                failing_urns.append(full_urn)
    
    # If we couldn't extract full URNs, try to at least get resource names
    if not failing_urns:
        resource_pattern = r'([A-Za-z0-9_-]+)\s+\*\*deleting failed\*\*'
        for line in output.split('\n'):
            resource_matches = re.findall(resource_pattern, line)
            if resource_matches:
                failing_urns.extend(resource_matches)
    
    return failing_urns

def process_pulumi_directory(
    dir_path: Path,
    build_path: Path,
    config: Config,
    inner_stack: Optional[str] = None,
    is_preview: bool = False,
    verbose: bool = False,
) -> None:
    """Process a Pulumi directory for deployment or preview."""
    if verbose:
        print(f"Processing Pulumi directory in: {dir_path}")
    
    # Get absolute build path
    abs_build_path = build_path.absolute()
    
    # Create build directory
    abs_build_path.mkdir(parents=True, exist_ok=True)
    pulumi_state_path = abs_build_path / ".pulumi"
    pulumi_state_path.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables - ensure Pulumi uses the right state directory
    os.environ["PULUMI_HOME"] = str(pulumi_state_path)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Clear any locks that might exist
    clear_locks_for_stack(pulumi_state_path, config.stack_name, verbose)
    
    # Create a subprocess environment with the correct PULUMI_HOME
    env = os.environ.copy()
    
    # Copy files from dir_path to build_path using shutil
    for entry in dir_path.iterdir():
        if entry.is_file() and entry.name != "Pulumi.yaml":
            dest_path = abs_build_path / entry.name
            try:
                shutil.copy2(entry, dest_path)  # copy2 preserves metadata
            except shutil.Error as e:
                if verbose:
                    print(f"{Fore.YELLOW}Warning copying {entry.name}: {str(e)}{Style.RESET_ALL}")
    
    # Render Pulumi.yaml if it exists
    if (dir_path / "Pulumi.yaml").exists():
        render_template(
            dir_path / "Pulumi.yaml",
            abs_build_path / "Pulumi.yaml",
            config,
            verbose
        )
    
    # Check if we have an existing stack
    stack_exists = False
    try:
        # Run direct Pulumi command to check if stack exists
        result = subprocess.run(
            ["pulumi", "stack", "ls"],
            cwd=str(abs_build_path),
            env=env,
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0 and config.stack_name in result.stdout:
            stack_exists = True
            if verbose:
                print(f"{Fore.GREEN}Found existing stack: {config.stack_name}{Style.RESET_ALL}")
        else:
            if verbose:
                print(f"{Fore.YELLOW}No existing stack found named: {config.stack_name}{Style.RESET_ALL}")
    except Exception as e:
        if verbose:
            print(f"{Fore.YELLOW}Error checking for existing stack: {str(e)}{Style.RESET_ALL}")
    
    # Define an empty program function
    def empty_program():
        pass
    
    # Initialize Pulumi backend using Automation API
    stack = None
    try:
        # First, try to login to local backend using subprocess
        if verbose:
            print(f"{Fore.CYAN}Logging in to Pulumi backend...{Style.RESET_ALL}")
        login_attempts = [
            ["pulumi", "login", "file://~", "--local"],
            ["pulumi", "login", "file://", "--local"],
            ["pulumi", "login", "file://~"],
            ["pulumi", "login", "file://"]
        ]
        
        login_success = False
        if verbose:
            print(f"{Fore.CYAN}Attempting to login to Pulumi backend...{Style.RESET_ALL}")

        for login_cmd in login_attempts:
            try:
                result = subprocess.run(
                    login_cmd,
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                if result.returncode == 0:
                    login_success = True
                    print(f"{Fore.GREEN}Login successful{Style.RESET_ALL}")
                    break
                elif verbose:
                    print(f"{Fore.YELLOW}Login attempt failed: {' '.join(login_cmd)}{Style.RESET_ALL}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Login exception: {str(e)}{Style.RESET_ALL}")

        # And update the refresh output:
        # Find this:
        print(f"{Fore.CYAN}Refreshing state...{Style.RESET_ALL}")

        # Add a try/except to handle the error you're seeing:
        print(f"{Fore.CYAN}Refreshing state...{Style.RESET_ALL}")
        try:
            # The refresh command has an issue with --ignore-remote-errors in some Pulumi versions
            # So we'll use a more compatible approach
            refresh_result = subprocess.run(
                ["pulumi", "refresh", "--yes", "--stack", config.stack_name, "--skip-preview"],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            if refresh_result.returncode == 0:
                if verbose:
                    print(f"{Fore.GREEN}Refresh completed successfully{Style.RESET_ALL}")
            else:
                if verbose:
                    print(f"{Fore.YELLOW}Refresh completed with warnings or errors{Style.RESET_ALL}")
        except Exception as e:
            if "stdout and stderr arguments may not be used with capture_output" in str(e):
                # This is a known issue with subprocess in some Python versions
                try:
                    # Try alternative approach without capture_output
                    refresh_result = subprocess.run(
                        ["pulumi", "refresh", "--yes", "--stack", config.stack_name, "--skip-preview"],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=True,
                        text=True
                    )
                    if verbose:
                        print(f"{Fore.GREEN}Refresh completed with alternative method{Style.RESET_ALL}")
                except Exception as alt_e:
                    print(f"{Fore.YELLOW}Refresh could not be completed: {str(alt_e)}{Style.RESET_ALL}")
            else:
                print(f"{Fore.YELLOW}Refresh warnings: {str(e)}{Style.RESET_ALL}")

        # Initialize workspace
        workspace = automation.LocalWorkspace(
            work_dir=str(abs_build_path),
            pulumi_home=str(pulumi_state_path)
        )
        
        # Handle stack creation/selection
        if stack_exists:
            print(f"{Fore.CYAN}Using existing stack: {config.stack_name}{Style.RESET_ALL}")
            try:
                # First, try direct command to select stack
                select_result = subprocess.run(
                    ["pulumi", "stack", "select", config.stack_name],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                if select_result.returncode != 0 and verbose:
                    print(f"{Fore.YELLOW}Note: Failed to select stack using command line, trying automation API{Style.RESET_ALL}")
                
                # Now use automation API
                stack = automation.select_stack(
                    stack_name=config.stack_name,
                    work_dir=str(abs_build_path),
                    program=empty_program,
                )
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Error selecting stack, will try to create it: {str(e)}{Style.RESET_ALL}")
                stack_exists = False

        if not stack_exists:
            print(f"{Fore.CYAN}Stack '{config.stack_name}' not found. Creating new stack...{Style.RESET_ALL}")
            
            # Create project file if it doesn't exist
            if not (abs_build_path / "Pulumi.yaml").exists():
                project_name = "bli-project"
                with open(abs_build_path / "Pulumi.yaml", "w") as f:
                    f.write(f"name: {project_name}\nruntime: yaml\ndescription: BLI Project\n")
            
            # Try to create the stack using direct command first
            create_result = subprocess.run(
                ["pulumi", "stack", "init", config.stack_name, "--non-interactive"],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            if create_result.returncode == 0:
                print(f"{Fore.GREEN}Created stack: {config.stack_name}{Style.RESET_ALL}")
            elif "already exists" in (create_result.stdout + create_result.stderr):
                print(f"{Fore.GREEN}Stack already exists, selecting it{Style.RESET_ALL}")
            else:
                if verbose:
                    print(f"{Fore.YELLOW}Direct stack creation failed, trying automation API: {create_result.stderr}{Style.RESET_ALL}")

            # Now use automation API
            try:
                stack = automation.select_stack(
                    stack_name=config.stack_name,
                    work_dir=str(abs_build_path),
                    program=empty_program,
                )
                if verbose:
                    print(f"{Fore.GREEN}Selected existing stack: {config.stack_name}{Style.RESET_ALL}")
            except Exception:
                stack = automation.create_stack(
                    stack_name=config.stack_name,
                    work_dir=str(abs_build_path),
                    program=empty_program,
                )
                print(f"{Fore.GREEN}Created stack: {config.stack_name}{Style.RESET_ALL}")
        
        # Configure stack
        stack.set_config("gcp:project", automation.ConfigValue(value=config.project_id))
        stack.set_config("project", automation.ConfigValue(value=config.project_id))
        
        # Execute preview or update based on is_preview flag
        if is_preview:
            print(f"{Fore.CYAN}Previewing changes for stack '{config.stack_name}'...{Style.RESET_ALL}")
            preview_result = stack.preview(on_output=print if verbose else None)
            print(f"Preview completed with {len(preview_result.change_summary)} changes")
            # Print detailed change summary
            has_changes = False
            for op_type, count in preview_result.change_summary.items():
                if count > 0:
                    has_changes = True
                    print(f"  {op_type}: {count}")
            
            if not has_changes:
                print(f"{Fore.GREEN}No changes required{Style.RESET_ALL}")
        else:
            # First, try to refresh the stack to sync state with cloud
            print(f"{Fore.CYAN}Refreshing state...{Style.RESET_ALL}")
            
            # Try using --refresh flag with up command instead of separate refresh command
            refresh_output = ""
            try:
                # The refresh command has an issue with --ignore-remote-errors in some Pulumi versions
                # So we'll use a more compatible approach
                refresh_result = subprocess.run(
                    ["pulumi", "refresh", "--yes", "--stack", config.stack_name, "--skip-preview"],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True,
                    stderr=subprocess.PIPE
                )
                
                refresh_output = refresh_result.stdout
                refresh_error = refresh_result.stderr
                
                # Check for flag error in stderr and retry without the flag if needed
                if "unknown flag" in refresh_error and "--ignore-remote-errors" in refresh_error:
                    if verbose:
                        print(f"{Fore.YELLOW}Retrying refresh without --ignore-remote-errors flag{Style.RESET_ALL}")
                    refresh_result = subprocess.run(
                        ["pulumi", "refresh", "--yes", "--stack", config.stack_name, "--skip-preview"],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=True,
                        text=True
                    )
                    refresh_output = refresh_result.stdout + refresh_result.stderr
                
                # Check for "resource already exists" message in refresh
                if "Error 409" in refresh_output and "already own it" in refresh_output:
                    simplified = simplify_resource_error(refresh_output)
                    print(simplified)
                    return  # Exit early as resource already exists
                elif refresh_result.returncode == 0:
                    if verbose:
                        print(f"{Fore.GREEN}Refresh completed successfully{Style.RESET_ALL}")
                else:
                    if verbose:
                        print(f"{Fore.YELLOW}Refresh completed with warnings or errors{Style.RESET_ALL}")
                    
                    # Simplify error output
                    simplified = simplify_resource_error(refresh_output)
                    if simplified != refresh_output:
                        print(simplified)
                    elif verbose:
                        print(refresh_output)
                
                # Check if we need to fix missing resources in state
                if "not found" in refresh_output.lower() or "does not exist" in refresh_output.lower():
                    if verbose:
                        print(f"{Fore.YELLOW}Detected missing resources in refresh. Attempting to fix state...{Style.RESET_ALL}")
                    
                    # Extract failing resources from refresh output
                    failing_resources = extract_failing_resources(refresh_output)
                    
                    if failing_resources:
                        if verbose:
                            print(f"{Fore.YELLOW}Identified failing resources: {failing_resources}{Style.RESET_ALL}")
                        
                        # Export state
                        export_result = subprocess.run(
                            ["pulumi", "stack", "export", "--stack", config.stack_name],
                            cwd=str(abs_build_path),
                            env=env,
                            capture_output=True,
                            text=True
                        )
                        
                        if export_result.returncode == 0 and export_result.stdout:
                            try:
                                # Parse the state
                                state = json.loads(export_result.stdout)
                                
                                if 'resources' in state:
                                    original_count = len(state['resources'])
                                    
                                    # Filter out failing resources
                                    filtered_resources = []
                                    for resource in state['resources']:
                                        should_keep = True
                                        resource_urn = resource.get('urn', '')
                                        
                                        # Check if this resource matches any failing resource
                                        for failing in failing_resources:
                                            if failing in resource_urn:
                                                should_keep = False
                                                break
                                        
                                        if should_keep:
                                            filtered_resources.append(resource)
                                    
                                    state['resources'] = filtered_resources
                                    removed_count = original_count - len(filtered_resources)
                                    
                                    if removed_count > 0:
                                        if verbose:
                                            print(f"{Fore.GREEN}Removed {removed_count} problematic resources from state{Style.RESET_ALL}")
                                        
                                        # Write fixed state to file
                                        state_file = abs_build_path / "fixed-state.json"
                                        with open(state_file, 'w') as f:
                                            json.dump(state, f)
                                        
                                        # Import fixed state
                                        import_result = subprocess.run(
                                            ["pulumi", "stack", "import", "--file", str(state_file), "--stack", config.stack_name],
                                            cwd=str(abs_build_path),
                                            env=env,
                                            capture_output=True,
                                            text=True
                                        )
                                        
                                        if import_result.returncode == 0:
                                            if verbose:
                                                print(f"{Fore.GREEN}Successfully imported fixed state{Style.RESET_ALL}")
                                        elif verbose:
                                            print(f"{Fore.YELLOW}State import warning: {import_result.stderr}{Style.RESET_ALL}")
                            except Exception as json_error:
                                if verbose:
                                    print(f"{Fore.YELLOW}Error processing state JSON: {str(json_error)}{Style.RESET_ALL}")
            except Exception as refresh_error:
                if verbose:
                    print(f"{Fore.YELLOW}Refresh failed: {str(refresh_error)}{Style.RESET_ALL}")
            
            # Clear locks again before deployment
            clear_locks_for_stack(pulumi_state_path, config.stack_name, verbose)
            
            # Now try the deployment
            print(f"{Fore.CYAN}Deploying stack '{config.stack_name}'...{Style.RESET_ALL}")
            
            try:
                # First, try a direct Pulumi up command
                up_result = subprocess.run(
                    ["pulumi", "up", "--yes", "--stack", config.stack_name, "--skip-preview"],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,  # Capture for error analysis
                    text=True
                )
                
                up_output = up_result.stdout + up_result.stderr
                
                # Check for resource already exists (409 Conflict) error
                if "Error 409" in up_output and "already own it" in up_output:
                    simplified = simplify_resource_error(up_output)
                    print(simplified)
                    print(f"{Fore.GREEN}Resource already exists and you own it. No action needed.{Style.RESET_ALL}")
                    # Consider this a success and return
                    return
                
                # Process and display output
                if up_result.returncode == 0:
                    print(f"{Fore.GREEN}Deployment completed successfully{Style.RESET_ALL}")
                    
                    # Extract and show only the resources section for non-verbose output
                    if not verbose:
                        resources_section = re.search(r'Resources:.*?(?=Duration|\Z)', up_output, re.DOTALL)
                        if resources_section:
                            summary = resources_section.group(0).strip()
                            print(summary)
                    else:
                        # Show full output in verbose mode
                        print(up_output)
                else:
                    # For errors, always simplify
                    simplified_output = simplify_resource_error(up_output)
                    if simplified_output != up_output:
                        print(f"Simplified error: {simplified_output}")
                        if verbose:
                            print("Raw output:")
                            print(up_output)
                    else:
                        print(up_output)
                    
                    # Check for "not found" or "does not exist" errors
                    if "not found" in up_output.lower() or "does not exist" in up_output.lower():
                        print(f"{Fore.YELLOW}Deployment failed due to missing resources.{Style.RESET_ALL}")
                        
                        # Extract failing resources for replacement
                        failing_resources = extract_failing_resources(up_output)
                        
                        if failing_resources:
                            if verbose:
                                print(f"{Fore.YELLOW}Attempting to replace resources: {failing_resources}{Style.RESET_ALL}")
                            else:
                                print(f"{Fore.YELLOW}Attempting to replace failing resources...{Style.RESET_ALL}")
                            
                            # Try replacing each failing resource
                            replace_success = False
                            for res in failing_resources:
                                try:
                                    replace_cmd = ["pulumi", "up", "--yes", "--stack", config.stack_name, "--replace", res]
                                    if verbose:
                                        print(f"Running: {' '.join(replace_cmd)}")
                                    
                                    replace_result = subprocess.run(
                                        replace_cmd,
                                        cwd=str(abs_build_path),
                                        env=env,
                                        capture_output=not verbose  # Show output directly only in verbose mode
                                    )
                                    
                                    if replace_result.returncode == 0:
                                        replace_success = True
                                        print(f"{Fore.GREEN}Successfully replaced resource{Style.RESET_ALL}")
                                        break
                                except Exception as replace_error:
                                    if verbose:
                                        print(f"{Fore.YELLOW}Error replacing resource {res}: {str(replace_error)}{Style.RESET_ALL}")
                            
                            if not replace_success:
                                # Try with refresh only as a last resort
                                print(f"{Fore.YELLOW}Resource replacement failed, trying refresh-only update...{Style.RESET_ALL}")
                                full_refresh_result = subprocess.run(
                                    ["pulumi", "up", "--yes", "--stack", config.stack_name, "--refresh-only"],
                                    cwd=str(abs_build_path),
                                    env=env,
                                    capture_output=not verbose
                                )
                                
                                if full_refresh_result.returncode == 0:
                                    print(f"{Fore.GREEN}Refresh-only update succeeded{Style.RESET_ALL}")
                                    
                                    # Try normal update again
                                    final_up_result = subprocess.run(
                                        ["pulumi", "up", "--yes", "--stack", config.stack_name],
                                        cwd=str(abs_build_path),
                                        env=env,
                                        capture_output=not verbose
                                    )
                                    
                                    if final_up_result.returncode == 0:
                                        print(f"{Fore.GREEN}Final deployment succeeded{Style.RESET_ALL}")
                                    else:
                                        print(f"{Fore.RED}Final deployment failed{Style.RESET_ALL}")
                        else:
                            # If we couldn't identify specific resources, try refresh-only
                            print(f"{Fore.YELLOW}Could not identify specific failing resources, trying refresh-only update...{Style.RESET_ALL}")
                            refresh_only_result = subprocess.run(
                                ["pulumi", "up", "--yes", "--stack", config.stack_name, "--refresh-only"],
                                cwd=str(abs_build_path),
                                env=env,
                                capture_output=not verbose
                            )
                            
                            if refresh_only_result.returncode == 0:
                                print(f"{Fore.GREEN}Refresh-only update succeeded, trying normal update...{Style.RESET_ALL}")
                                # Try normal update again
                                final_up_result = subprocess.run(
                                    ["pulumi", "up", "--yes", "--stack", config.stack_name],
                                    cwd=str(abs_build_path),
                                    env=env,
                                    capture_output=not verbose
                                )
                                
                                if final_up_result.returncode == 0:
                                    print(f"{Fore.GREEN}Final deployment succeeded{Style.RESET_ALL}")
                                else:
                                    print(f"{Fore.RED}Final deployment failed{Style.RESET_ALL}")
                    else:
                        # If it's some other error, fall back to automation API
                        print(f"{Fore.YELLOW}Direct deployment command failed, trying alternative method...{Style.RESET_ALL}")
                        up_result = stack.up(on_output=print if verbose else None)
                        print(f"Deployment completed with status: {up_result.summary.result}")
            except Exception as deploy_error:
                print(f"{Fore.RED}Deployment failed: {str(deploy_error)}{Style.RESET_ALL}")
                raise
            
    except Exception as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        raise

def deploy_command(args: Namespace) -> None:
    """Execute the deploy command."""
    # Ensure paths are absolute
    abs_work_dir = args.work_dir.absolute()
    abs_build_dir = abs_work_dir / "build"
    
    # Print paths only in verbose mode
    if args.verbose:
        print(f"Using work directory: {abs_work_dir}")
        print(f"Using build directory: {abs_build_dir}")
    
    # Ensure build directory exists
    abs_build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create .pulumi directory if it doesn't exist
    pulumi_dir = abs_build_dir / ".pulumi"
    pulumi_dir.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables BEFORE any Pulumi operations
    os.environ["PULUMI_HOME"] = str(pulumi_dir)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Verify that Pulumi is using the correct home directory - only in verbose mode
    if args.verbose:
        try:
            result = subprocess.run(
                ["pulumi", "about"],
                env=os.environ.copy(),
                capture_output=True,
                text=True
            )
            if "PULUMI_HOME" in result.stdout:
                home_line = [line for line in result.stdout.splitlines() if "PULUMI_HOME" in line]
                print(f"Pulumi reports: {home_line[0] if home_line else 'PULUMI_HOME not found in output'}")
                
                # Check for incorrect paths in output and warn
                if str(pulumi_dir) not in ' '.join(home_line):
                    print(f"{Fore.RED}WARNING: Pulumi not using specified home directory!{Style.RESET_ALL}")
                    print(f"Expected: {pulumi_dir}")
        except Exception as e:
            print(f"Error running diagnostic: {str(e)}")
    
    # ONLY check for locks in our specified pulumi directory, not global ones
    locks_dir = pulumi_dir / "locks"
    if locks_dir.exists() and args.verbose:
        print(f"Checking for locks in: {locks_dir}")
        try:
            # Walk through all stack locks
            for stack_lock_dir in locks_dir.iterdir():
                if stack_lock_dir.is_dir():
                    print(f"Clearing locks for stack: {stack_lock_dir.name}")
                    for lock_file in stack_lock_dir.glob("*.json"):
                        try:
                            lock_file.unlink()
                            print(f"Removed lock file: {lock_file.name}")
                        except Exception as e:
                            print(f"Could not remove lock file {lock_file.name}: {str(e)}")
        except Exception as e:
            print(f"Error cleaning lock directories: {str(e)}")
    
    # Get stack name and create config
    stack_name = get_stack_name(args.stack_name, abs_work_dir)
    config = Config.from_cli(
        stack_name=stack_name,
        project_id=args.project_id,
        proxy_address=args.proxy_address,
        proxy_port=args.proxy_port,
        use_local_auth=args.use_local_auth,
        no_proxy=args.no_proxy,
        staging=args.stg,
        service=args.srv,
    )
    
    setup_proxy(config)
    setup_gcloud(config)
    
    # For extra safety, copy any Pulumi files from work dir to build dir
    for entry in abs_work_dir.glob("Pulumi.*"):
        if entry.is_file():
            target = abs_build_dir / entry.name
            try:
                shutil.copy2(entry, target)
                if args.verbose:
                    print(f"Copied Pulumi file: {entry.name}")
            except Exception as e:
                if args.verbose:
                    print(f"Failed to copy {entry.name}: {str(e)}")
    
    # Set specific command-line options for every Pulumi command
    os.environ["PULUMI_SKIP_UPDATE_CHECK"] = "true"  # Skip update checks
    
    # Run the process with 100% environment-based state path
    process_pulumi_directory(abs_work_dir, abs_build_dir, config, None, False, args.verbose)import shutil
from argparse import Namespace
from pathlib import Path
from typing import Optional

from colorama import Fore, Style

def clear_lock_file(work_dir: Path, stack_name: Optional[str] = None) -> None:
    """Clear Pulumi lock files."""
    build_path = work_dir / "build"
    base_locks_path = build_path / ".pulumi" / "locks"
    
    if stack_name:
        # Path for specific stack's lock
        stack_lock_path = base_locks_path / "organization" / "test-stack" / stack_name
        
        if stack_lock_path.exists():
            shutil.rmtree(stack_lock_path)
            print(f"{Fore.GREEN}Successfully removed stack lock directory{Style.RESET_ALL}")
            print(f"Lock directory location: {stack_lock_path}")
        else:
            print(f"{Fore.YELLOW}No lock directory found for stack{Style.RESET_ALL}")
            print(f"Checked location: {stack_lock_path}")
    else:
        # If no stack specified, remove the entire locks directory
        if base_locks_path.exists():
            shutil.rmtree(base_locks_path)
            print(f"{Fore.GREEN}Successfully removed all locks directory{Style.RESET_ALL}")
            print(f"Locks directory location: {base_locks_path}")
        else:
            print(f"{Fore.YELLOW}No locks directory found{Style.RESET_ALL}")
            print(f"Checked location: {base_locks_path}")

def clear_command(args: Namespace) -> None:
    """Execute the clear command."""
    clear_lock_file(args.work_dir, args.stack_name)from argparse import Namespace
from pathlib import Path
import os
import shutil
import subprocess
from typing import Optional

from colorama import Fore, Style

from bli.utils.config import Config, get_stack_name, setup_gcloud, setup_proxy
from bli.utils.pulumi_utils import run_pulumi_command, colorize_pulumi_output, fix_state_for_missing_resources
from bli.utils.templating import render_template
from bli.commands.clear import clear_lock_file

def simplify_resource_error(error_output: str) -> str:
    """Convert verbose cloud provider errors into simplified, user-friendly messages."""
    
    # Bucket already exists (GCP 409 Conflict)
    if "Error 409" in error_output and "already own it" in error_output:
        return f"{Fore.YELLOW}The resource already exists and you already own it. No changes required.{Style.RESET_ALL}"
    
    # Not found errors
    if "Error 404" in error_output and "not found" in error_output:
        return f"{Fore.YELLOW}The resource doesn't exist in the cloud provider.{Style.RESET_ALL}"
        
    # Permission errors
    if "Error 403" in error_output and ("permission" in error_output.lower() or "forbidden" in error_output.lower()):
        return f"{Fore.RED}You don't have sufficient permissions to perform this operation.{Style.RESET_ALL}"
    
    # Quota exceeded
    if "quota" in error_output.lower() and "exceed" in error_output.lower():
        return f"{Fore.RED}Quota exceeded for this resource. Please check your GCP quotas.{Style.RESET_ALL}"
    
    # Filter out help text for commands
    if "Usage:" in error_output and "Flags:" in error_output:
        lines = error_output.split('\n')
        filtered_lines = []
        in_help_section = False
        
        for line in lines:
            if "Usage:" in line:
                in_help_section = True
                # Add only the error line before usage
                for i in range(len(filtered_lines)-1, -1, -1):
                    if "error:" in filtered_lines[i].lower():
                        filtered_lines = filtered_lines[:i+1]
                        break
                continue
            elif not in_help_section or "error:" in line.lower():
                filtered_lines.append(line)
        
        return '\n'.join(filtered_lines)
    
    # Generic error - truncate the verbose parts
    if "error:" in error_output:
        # Get just the core error message
        for line in error_output.split('\n'):
            if "googleapi: Error" in line:
                parts = line.split("googleapi: Error ")
                if len(parts) > 1:
                    error_code = parts[1].split(':', 1)[0]
                    error_message = parts[1].split(':', 1)[1].split(',')[0] if ':' in parts[1] else parts[1]
                    return f"{Fore.RED}GCP Error {error_code}: {error_message}{Style.RESET_ALL}"
    
    # Return original if no simplification was possible
    return error_output

def clear_locks_for_stack(pulumi_home: Path, stack_name: str, verbose: bool = False) -> None:
    """Clear any lock files for the given stack."""
    locks_dir = pulumi_home / "locks" / stack_name
    if locks_dir.exists():
        if verbose:
            print(f"Clearing locks for stack '{stack_name}'...")
        try:
            for lock_file in locks_dir.glob("*.json"):
                try:
                    lock_file.unlink()
                    if verbose:
                        print(f"Removed lock file: {lock_file.name}")
                except Exception as e:
                    if verbose:
                        print(f"Could not remove lock file {lock_file.name}: {str(e)}")
        except Exception as e:
            if verbose:
                print(f"Error clearing locks: {str(e)}")

def process_pulumi_destroy(
    dir_path: Path,
    build_path: Path,
    config: Config,
    verbose: bool = False,
) -> None:
    """Process a Pulumi stack destruction."""
    if verbose:
        print(f"Processing Pulumi destroy in: {dir_path}")
    
    # Get absolute build path
    abs_build_path = build_path.absolute()
    
    # Create build directory
    abs_build_path.mkdir(parents=True, exist_ok=True)
    pulumi_state_path = abs_build_path / ".pulumi"
    pulumi_state_path.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables - ensure Pulumi uses the right state directory
    os.environ["PULUMI_HOME"] = str(pulumi_state_path)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Clear any locks that might exist
    clear_locks_for_stack(pulumi_state_path, config.stack_name, verbose)
    
    # Create a subprocess environment with the correct PULUMI_HOME
    env = os.environ.copy()
    
    # Copy files from dir_path to build_path
    for entry in dir_path.iterdir():
        if entry.is_file() and entry.name != "Pulumi.yaml":
            try:
                dest_path = abs_build_path / entry.name
                shutil.copy2(entry, dest_path)  # copy2 preserves metadata
                if verbose:
                    print(f"Copied file: {entry.name}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Warning copying {entry.name}: {str(e)}{Style.RESET_ALL}")
    
    # Render Pulumi.yaml if it exists using the templating utility
    if (dir_path / "Pulumi.yaml").exists():
        try:
            render_template(
                dir_path / "Pulumi.yaml",
                abs_build_path / "Pulumi.yaml",
                config,
                verbose
            )
            print(f"{Fore.GREEN}Rendered Pulumi.yaml template{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.YELLOW}Error rendering template: {str(e)}. Trying direct copy.{Style.RESET_ALL}")
            try:
                shutil.copy2(dir_path / "Pulumi.yaml", abs_build_path / "Pulumi.yaml")
                print(f"Copied Pulumi.yaml (unprocessed)")
            except Exception as copy_error:
                print(f"{Fore.RED}Failed to copy Pulumi.yaml: {str(copy_error)}{Style.RESET_ALL}")
    
    try:
        # Login to Pulumi backend
        if verbose:
            print(f"{Fore.CYAN}Logging in to Pulumi backend...{Style.RESET_ALL}")
        
        login_attempts = [
            ["pulumi", "login", "file://~", "--local"],
            ["pulumi", "login", "file://", "--local"],
            ["pulumi", "login", "file://~"],
            ["pulumi", "login", "file://"]
        ]
        
        login_success = False
        for login_cmd in login_attempts:
            try:
                if verbose:
                    print(f"Attempting login with: {' '.join(login_cmd)}")
                
                result = subprocess.run(
                    login_cmd,
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    login_success = True
                    print(f"{Fore.GREEN}Login successful with command: {' '.join(login_cmd)}{Style.RESET_ALL}")
                    break
                elif verbose:
                    print(f"{Fore.YELLOW}Login attempt failed with: {' '.join(login_cmd)}{Style.RESET_ALL}")
                    print(f"Error: {result.stderr.strip()}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Login exception: {str(e)}{Style.RESET_ALL}")
        
        # If all attempts failed, try just --local without URL
        if not login_success:
            # Try an alternative login approach
            simple_login_cmd = ["pulumi", "login", "--local"]
            try:
                if verbose:
                    print(f"Attempting login with: {' '.join(simple_login_cmd)}")
                
                result = subprocess.run(
                    simple_login_cmd,
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    login_success = True
                    print(f"{Fore.GREEN}Login successful with command: {' '.join(simple_login_cmd)}{Style.RESET_ALL}")
                else:
                    if verbose:
                        print(f"{Fore.YELLOW}Login attempt failed with: {' '.join(simple_login_cmd)}{Style.RESET_ALL}")
                        print(f"Error: {result.stderr.strip()}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Login exception: {str(e)}{Style.RESET_ALL}")
        
        # Check if stack exists
        stack_exists = False
        try:
            if verbose:
                print(f"Looking for stack '{config.stack_name}' in current project...")
            
            # First check if Pulumi.yaml exists in the build directory
            if not (abs_build_path / "Pulumi.yaml").exists():
                print(f"{Fore.YELLOW}Warning: No Pulumi.yaml found in {abs_build_path}. Creating a minimal one.{Style.RESET_ALL}")
                # Create a basic Pulumi.yaml file
                with open(abs_build_path / "Pulumi.yaml", "w") as f:
                    f.write("name: bli-project\nruntime: yaml\ndescription: BLI Project\n")
            
            # Try to list stacks
            stack_ls_result = subprocess.run(
                ["pulumi", "stack", "ls"],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            # Check if the specific stack exists in the output
            found_in_list = False
            if stack_ls_result.returncode == 0:
                # Parse the output to look specifically for our stack
                lines = stack_ls_result.stdout.strip().split('\n')
                for line in lines:
                    if config.stack_name in line:
                        found_in_list = True
                        if verbose:
                            print(f"{Fore.GREEN}Found stack in list: {line.strip()}{Style.RESET_ALL}")
                        break
                
                if verbose and not found_in_list:
                    print(f"{Fore.YELLOW}Stack '{config.stack_name}' not found in stack listing{Style.RESET_ALL}")
            elif verbose:
                print(f"{Fore.YELLOW}Error listing stacks: {stack_ls_result.stderr.strip()}{Style.RESET_ALL}")
            
            # Make additional check for the stack's state file directly
            stack_state_dir = pulumi_state_path / "stacks"
            stack_state_path = None
            
            if stack_state_dir.exists():
                state_files_found = False
                for path in stack_state_dir.glob(f"*{config.stack_name}*"):
                    state_files_found = True
                    if path.is_file() and "stack.json" in str(path):
                        stack_state_path = path
                        stack_exists = True
                        print(f"{Fore.GREEN}Found stack state file for '{config.stack_name}'{Style.RESET_ALL}")
                        break
                    elif path.is_dir():
                        state_file = path / "stack.json"
                        if state_file.exists():
                            stack_state_path = state_file
                            stack_exists = True
                            print(f"{Fore.GREEN}Found stack state file for '{config.stack_name}'{Style.RESET_ALL}")
                            break
                
                if verbose and not state_files_found:
                    print(f"{Fore.YELLOW}No state files found for stack '{config.stack_name}' in {stack_state_dir}{Style.RESET_ALL}")
            
            # Check output of stack ls
            if not stack_exists and found_in_list:
                stack_exists = True
                print(f"{Fore.GREEN}Found stack '{config.stack_name}' in Pulumi stack list{Style.RESET_ALL}")
                
            if not stack_exists:
                print(f"{Fore.RED}Stack '{config.stack_name}' not found. Cannot destroy a non-existent stack.{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}Checked in {stack_state_dir} and in the Pulumi stack listing.{Style.RESET_ALL}")
                return
                
        except Exception as e:
            print(f"{Fore.RED}Error checking for stack: {str(e)}{Style.RESET_ALL}")
            return
        
        # Select stack if it exists
        if stack_exists:
            select_result = subprocess.run(
                ["pulumi", "stack", "select", config.stack_name],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            if select_result.returncode == 0:
                if verbose:
                    print(f"{Fore.GREEN}Selected stack: {config.stack_name}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Failed to select stack: {select_result.stderr.strip()}{Style.RESET_ALL}")
                return
            
            # Try to fix any state issues before destroying
            try:
                print(f"{Fore.CYAN}Refreshing state before destroy...{Style.RESET_ALL}")
                # Use refresh with ignore-remote-errors to handle missing resources
                refresh_result = subprocess.run(
                    ["pulumi", "refresh", "--yes", "--stack", config.stack_name, "--skip-preview"],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                # Even if refresh fails, we'll still attempt to destroy
                if refresh_result.returncode != 0 and verbose:
                    print(f"{Fore.YELLOW}Refresh completed with warnings or errors. Continuing with destroy...{Style.RESET_ALL}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Refresh failed: {str(e)}. Continuing with destroy...{Style.RESET_ALL}")
            
            # First attempt - try destroy with normal options
            print(f"{Fore.CYAN}Destroying stack '{config.stack_name}'...{Style.RESET_ALL}")
            
            # Ask for confirmation
            confirmation = input(f"{Fore.YELLOW}WARNING: This will destroy all resources in stack '{config.stack_name}'.\nAre you sure you want to continue? (yes/no): {Style.RESET_ALL}")
            if confirmation.lower() not in ["yes", "y"]:
                print(f"{Fore.GREEN}Destroy operation cancelled.{Style.RESET_ALL}")
                return
            
            # Try to destroy the stack
            destroy_success = False
            try:
                destroy_result = subprocess.run(
                    ["pulumi", "destroy", "--yes", "--stack", config.stack_name, "--skip-preview"],
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                destroy_output = destroy_result.stdout + destroy_result.stderr
                
                # Check for common errors and handle them
                if destroy_result.returncode == 0:
                    print(f"{Fore.GREEN}Stack successfully destroyed{Style.RESET_ALL}")
                    destroy_success = True
                
                # Print the colorized output
                colored_output = colorize_pulumi_output(destroy_output)
                print(colored_output)
                
            except Exception as e:
                print(f"{Fore.RED}Error during destroy: {str(e)}{Style.RESET_ALL}")
            
            # If destroy failed, try with --refresh-only first, then destroy again
            if not destroy_success:
                print(f"{Fore.YELLOW}First destroy attempt failed. Trying with refresh-only...{Style.RESET_ALL}")
                try:
                    # First run a refresh-only update
                    subprocess.run(
                        ["pulumi", "up", "--refresh-only", "--yes", "--stack", config.stack_name],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=not verbose
                    )
                    
                    # Then try destroying again
                    print(f"{Fore.CYAN}Retrying destroy...{Style.RESET_ALL}")
                    destroy_result = subprocess.run(
                        ["pulumi", "destroy", "--yes", "--stack", config.stack_name, "--skip-preview"],
                        cwd=str(abs_build_path),
                        env=env,
                        capture_output=True,
                        text=True
                    )
                    
                    destroy_output = destroy_result.stdout + destroy_result.stderr
                    colored_output = colorize_pulumi_output(destroy_output)
                    print(colored_output)
                    
                    if destroy_result.returncode == 0:
                        print(f"{Fore.GREEN}Stack successfully destroyed on second attempt{Style.RESET_ALL}")
                        destroy_success = True
                    
                except Exception as e:
                    print(f"{Fore.RED}Error during second destroy attempt: {str(e)}{Style.RESET_ALL}")
            
            # If destroy is still failing, attempt to forcefully remove the stack
            if not destroy_success:
                print(f"{Fore.YELLOW}Destroy failed. Do you want to force-remove the stack? This will remove the stack metadata without destroying resources.{Style.RESET_ALL}")
                force_remove = input(f"{Fore.YELLOW}Force remove stack? (yes/no): {Style.RESET_ALL}")
                
                if force_remove.lower() in ["yes", "y"]:
                    try:
                        # Force remove the stack
                        remove_result = subprocess.run(
                            ["pulumi", "stack", "rm", "--yes", "--force", config.stack_name],
                            cwd=str(abs_build_path),
                            env=env,
                            capture_output=True,
                            text=True
                        )
                        
                        if remove_result.returncode == 0:
                            print(f"{Fore.GREEN}Stack metadata forcefully removed. Note that cloud resources may still exist.{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Failed to force-remove stack: {remove_result.stderr.strip()}{Style.RESET_ALL}")
                    except Exception as e:
                        print(f"{Fore.RED}Error during force-remove: {str(e)}{Style.RESET_ALL}")
                else:
                    print(f"{Fore.YELLOW}Force-remove cancelled. Stack remains with possible resource leaks.{Style.RESET_ALL}")
            
            # If destroy was successful, offer to remove the stack metadata
            if destroy_success:
                print(f"{Fore.CYAN}Do you want to remove the stack metadata? This will completely remove the stack from Pulumi.{Style.RESET_ALL}")
                remove_stack = input(f"{Fore.YELLOW}Remove stack metadata? (yes/no): {Style.RESET_ALL}")
                
                if remove_stack.lower() in ["yes", "y"]:
                    try:
                        # Remove the stack
                        remove_result = subprocess.run(
                            ["pulumi", "stack", "rm", "--yes", config.stack_name],
                            cwd=str(abs_build_path),
                            env=env,
                            capture_output=True,
                            text=True
                        )
                        
                        if remove_result.returncode == 0:
                            print(f"{Fore.GREEN}Stack metadata removed. Cleanup complete.{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Failed to remove stack metadata: {remove_result.stderr.strip()}{Style.RESET_ALL}")
                    except Exception as e:
                        print(f"{Fore.RED}Error removing stack metadata: {str(e)}{Style.RESET_ALL}")
                else:
                    print(f"{Fore.YELLOW}Stack metadata preserved. You can reuse this stack in the future.{Style.RESET_ALL}")
        
    except Exception as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        raise

def destroy_command(args: Namespace) -> None:
    """Execute the destroy command."""
    # Ensure paths are absolute
    abs_work_dir = args.work_dir.absolute()
    abs_build_dir = abs_work_dir / "build"
    
    # Check if verbose flag exists in args
    verbose = getattr(args, 'verbose', False)
    
    # Always print paths for better debugging
    print(f"Using work directory: {abs_work_dir}")
    print(f"Using build directory: {abs_build_dir}")
    
    # Ensure build directory exists
    abs_build_dir.mkdir(parents=True, exist_ok=True)
    
    # Check for existing Pulumi state in common locations
    standard_pulumi_home = Path.home() / ".pulumi"
    if verbose and standard_pulumi_home.exists():
        print(f"Found standard Pulumi home directory at: {standard_pulumi_home}")
    
    # First, look for state in work_dir
    work_dir_pulumi = abs_work_dir / ".pulumi"
    if work_dir_pulumi.exists():
        if verbose:
            print(f"Found Pulumi state directory in work directory: {work_dir_pulumi}")
        # Use this as our state directory
        pulumi_dir = work_dir_pulumi
    else:
        # Use build directory for state
        pulumi_dir = abs_build_dir / ".pulumi"
        pulumi_dir.mkdir(parents=True, exist_ok=True)
        if verbose:
            print(f"Created Pulumi state directory: {pulumi_dir}")
    
    # Set environment variables BEFORE any Pulumi operations
    os.environ["PULUMI_HOME"] = str(pulumi_dir)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    os.environ["PULUMI_SKIP_UPDATE_CHECK"] = "true"  # Skip update checks
    
    if verbose:
        print(f"PULUMI_HOME set to: {os.environ['PULUMI_HOME']}")
    
    # Get stack name and create config
    stack_name = get_stack_name(args.stack_name, abs_work_dir)
    config = Config.from_cli(
        stack_name=stack_name,
        project_id=args.project_id,
        proxy_address=args.proxy_address,
        proxy_port=args.proxy_port,
        use_local_auth=args.use_local_auth,
        no_proxy=args.no_proxy,
        staging=args.stg,
        service=args.srv,
    )
    
    setup_proxy(config)
    setup_gcloud(config)
    
    # For extra safety, copy any Pulumi files from work dir to build dir
    for entry in abs_work_dir.glob("Pulumi.*"):
        if entry.is_file():
            target = abs_build_dir / entry.name
            try:
                shutil.copy2(entry, target)
                if verbose:
                    print(f"Copied Pulumi file: {entry.name}")
            except Exception as e:
                if verbose:
                    print(f"Failed to copy {entry.name}: {str(e)}")
    
    # Process the directory
    process_pulumi_destroy(abs_work_dir, abs_build_dir, config, verbose)import os
import shutil
import subprocess
import tempfile
import json
import re
from argparse import Namespace
from pathlib import Path
from typing import Optional, Dict, List, Any, Set, Tuple

from colorama import Fore, Style

from bli.utils.config import Config, get_stack_name, setup_gcloud, setup_proxy
from bli.utils.templating import render_template

def format_dot_output(dot_content: str) -> None:
    """
    Format a DOT graph into a more readable text representation.
    
    Args:
        dot_content: DOT graph content as string
    """
    # Parse nodes
    nodes = {}
    node_pattern = r'Resource(\d+) \[label="([^"]+)"\];'
    for match in re.finditer(node_pattern, dot_content):
        node_id = f"Resource{match.group(1)}"
        node_label = match.group(2)
        nodes[node_id] = node_label
    
    # Parse edges
    edges = []
    edge_pattern = r'Resource(\d+) -> Resource(\d+)'
    for match in re.finditer(edge_pattern, dot_content):
        source_id = f"Resource{match.group(1)}"
        target_id = f"Resource{match.group(2)}"
        # Try to extract label if present
        label = ""
        label_match = re.search(fr'{source_id} -> {target_id}\s*\[.*?label = "([^"]+)"', dot_content)
        if label_match:
            label = label_match.group(1)
        edges.append((source_id, target_id, label))
    
    # Format nodes for display
    formatted_nodes = {}
    for node_id, node_label in nodes.items():
        # Extract relevant parts from URN
        if node_label.startswith("urn:pulumi:"):
            parts = node_label.split("::")
            if len(parts) >= 3:
                resource_type = parts[-2] if len(parts) >= 5 else ""
                resource_name = parts[-1]
                
                if resource_type:
                    display_name = f"{Fore.GREEN}{resource_name}{Style.RESET_ALL} ({Fore.CYAN}{resource_type}{Style.RESET_ALL})"
                else:
                    display_name = f"{Fore.GREEN}{resource_name}{Style.RESET_ALL}"
                
                formatted_nodes[node_id] = display_name
        else:
            formatted_nodes[node_id] = f"{Fore.GREEN}{node_label}{Style.RESET_ALL}"
    
    # Print resources
    print(f"\n{Fore.BLUE}Resources:{Style.RESET_ALL}")
    for node_id, display_name in formatted_nodes.items():
        print(f"  {display_name}")
    
    # Print dependencies
    if edges:
        print(f"\n{Fore.BLUE}Dependencies:{Style.RESET_ALL}")
        for source_id, target_id, label in edges:
            source_name = formatted_nodes.get(source_id, source_id)
            target_name = formatted_nodes.get(target_id, target_id)
            
            if label:
                relationship = f"  {source_name} â†’ {target_name} ({Fore.YELLOW}{label}{Style.RESET_ALL})"
            else:
                relationship = f"  {source_name} â†’ {target_name}"
            
            print(relationship)

def display_simple_tree(dot_content: str, resources: List[Dict[str, Any]], resource_details: bool = False, verbose: bool = False):
    """
    Display a simple tree representation of the resource graph.
    
    Args:
        dot_content: DOT graph content as string
        resources: List of resource objects with details
        resource_details: Whether to show detailed resource information
        verbose: Whether to show verbose debug information
    """
    print(f"\n{Fore.CYAN}Resource Dependency Tree:{Style.RESET_ALL}")
    
    # For troubleshooting in verbose mode
    if verbose:
        print(f"{Fore.YELLOW}Debug: Raw DOT content sample:{Style.RESET_ALL}")
        print(dot_content[:500] + "..." if len(dot_content) > 500 else dot_content)
    
    # Step 1: Parse nodes
    nodes = {}
    node_pattern = r'Resource(\d+) \[label="([^"]+)"\];'
    for match in re.finditer(node_pattern, dot_content):
        node_id = f"Resource{match.group(1)}"
        node_label = match.group(2)
        nodes[node_id] = node_label
    
    if verbose:
        print(f"{Fore.YELLOW}Debug: Found {len(nodes)} nodes{Style.RESET_ALL}")
    
    # Step 2: Parse edges - more flexible pattern
    edges = []
    # First try the most specific pattern with color and possible label
    edge_pattern = r'Resource(\d+) -> Resource(\d+)(?: \[color[^]]*\])?;'
    for match in re.finditer(edge_pattern, dot_content):
        source_id = f"Resource{match.group(1)}"
        target_id = f"Resource{match.group(2)}"
        edges.append((source_id, target_id))
    
    if verbose:
        print(f"{Fore.YELLOW}Debug: Found {len(edges)} edges{Style.RESET_ALL}")
    
    # Step 3: Identify the stack resource (typically the root)
    stack_resource = None
    for node_id, label in nodes.items():
        if "::Stack::" in label:
            stack_resource = node_id
            break
    
    if not stack_resource and nodes:
        # If no stack resource found, use the first node
        stack_resource = next(iter(nodes.keys()))
    
    if not stack_resource:
        print(f"{Fore.RED}No resources found in the graph.{Style.RESET_ALL}")
        return
    
    # Step 4: Build a dependency tree
    # In Pulumi graphs, A -> B means A depends on B
    # For visualization, we want to show B as a parent of A
    dependency_map = {}
    for source, target in edges:
        # Add target as parent of source (source depends on target)
        if target not in dependency_map:
            dependency_map[target] = []
        if source not in dependency_map[target]:
            dependency_map[target].append(source)
    
    # Add all nodes to dependency_map if not already there
    for node in nodes:
        if node not in dependency_map:
            dependency_map[node] = []
    
    if verbose:
        print(f"{Fore.YELLOW}Debug: Built dependency map with {len(dependency_map)} entries{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Debug: Stack resource is {stack_resource}: {nodes.get(stack_resource, 'Unknown')}{Style.RESET_ALL}")
    
    # Step 5: Display the tree
    def print_node(node_id, prefix="", is_last=True, visited=None):
        if visited is None:
            visited = set()
        
        # Cycle detection
        if node_id in visited:
            if is_last:
                print(f"{prefix}â””â”€â”€ {Fore.YELLOW}(cycle back to {nodes.get(node_id, node_id)}){Style.RESET_ALL}")
            else:
                print(f"{prefix}â”œâ”€â”€ {Fore.YELLOW}(cycle back to {nodes.get(node_id, node_id)}){Style.RESET_ALL}")
            return
        
        visited.add(node_id)
        
        # Format node label
        node_label = nodes.get(node_id, node_id)
        display_name = node_label
        
        if node_label.startswith("urn:pulumi:"):
            parts = node_label.split("::")
            if len(parts) >= 5:
                resource_type = parts[-2]
                resource_name = parts[-1]
                display_name = f"{resource_name} ({resource_type})"
        
        # Get resource details
        detail_str = ""
        if resource_details:
            for resource in resources:
                if resource.get("urn") == node_label:
                    resource_id = resource.get("id", "")
                    if resource_id:
                        detail_str = f" - ID: {Fore.YELLOW}{resource_id}{Style.RESET_ALL}"
                    break
        
        # Print the node
        if not prefix:  # Root node
            print(f"{Fore.GREEN}{display_name}{Style.RESET_ALL}{detail_str}")
        else:
            if is_last:
                print(f"{prefix}â””â”€â”€ {Fore.GREEN}{display_name}{Style.RESET_ALL}{detail_str}")
                new_prefix = prefix + "    "
            else:
                print(f"{prefix}â”œâ”€â”€ {Fore.GREEN}{display_name}{Style.RESET_ALL}{detail_str}")
                new_prefix = prefix + "â”‚   "
        
        # Print children
        children = dependency_map.get(node_id, [])
        for i, child in enumerate(children):
            print_node(child, new_prefix, i == len(children) - 1, visited.copy())
    
    # Start with the stack resource or any node that has dependencies
    if stack_resource in dependency_map:
        print_node(stack_resource)
    else:
        # Plan B: Just print all resources
        print(f"{Fore.YELLOW}Could not build proper tree structure. Listing all resources:{Style.RESET_ALL}")
        for node_id, label in nodes.items():
            display_name = label
            if label.startswith("urn:pulumi:"):
                parts = label.split("::")
                if len(parts) >= 5:
                    resource_type = parts[-2]
                    resource_name = parts[-1]
                    display_name = f"{resource_name} ({resource_type})"
            print(f"â€¢ {Fore.GREEN}{display_name}{Style.RESET_ALL}")

def get_stack_resources(work_dir: Path, stack_name: str, env: Dict) -> List[Dict[str, Any]]:
    """
    Get detailed information about stack resources.
    
    Args:
        work_dir: Working directory path
        stack_name: Name of the Pulumi stack
        env: Environment variables
    
    Returns:
        List of resource objects with details
    """
    try:
        # Export the stack to get resource details
        result = subprocess.run(
            ["pulumi", "stack", "export", "--stack", stack_name],
            cwd=str(work_dir),
            env=env,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            return []
        
        # Parse the JSON output
        stack_data = json.loads(result.stdout)
        
        # Extract resources
        resources = []
        if "deployment" in stack_data and "resources" in stack_data["deployment"]:
            resources = stack_data["deployment"]["resources"]
        
        return resources
    except Exception:
        return []

def process_pulumi_graph(
    dir_path: Path,
    build_path: Path,
    config: Config,
    graph_format: str = "dot",
    save_to_file: Optional[Path] = None,
    verbose: bool = False,
    tree_view: bool = False,
    resource_details: bool = False,
    pretty_print: bool = False,
) -> None:
    """Generate a dependency graph for a Pulumi stack.
    
    Args:
        dir_path: Path to the directory containing Pulumi project
        build_path: Path to build directory where temporary files are stored
        config: Configuration object with stack settings
        graph_format: Output format (dot, json, or yaml)
        save_to_file: Optional file path to save the graph output
        verbose: If True, show verbose output
        tree_view: If True, display as a console tree
        resource_details: If True, show detailed resource information
        pretty_print: If True, display in a formatted text view
    """
    if verbose:
        print(f"Processing Pulumi graph in: {dir_path}")
    
    # Get absolute build path
    abs_build_path = build_path.absolute()
    
    # Create build directory
    abs_build_path.mkdir(parents=True, exist_ok=True)
    pulumi_state_path = abs_build_path / ".pulumi"
    pulumi_state_path.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables - ensure Pulumi uses the right state directory
    os.environ["PULUMI_HOME"] = str(pulumi_state_path)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    
    # Create a subprocess environment with the correct PULUMI_HOME
    env = os.environ.copy()
    
    # Copy files from dir_path to build_path
    for entry in dir_path.iterdir():
        if entry.is_file() and entry.name != "Pulumi.yaml":
            try:
                dest_path = abs_build_path / entry.name
                shutil.copy2(entry, dest_path)  # copy2 preserves metadata
                if verbose:
                    print(f"Copied file: {entry.name}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Warning copying {entry.name}: {str(e)}{Style.RESET_ALL}")
    
    # Render Pulumi.yaml if it exists using the templating utility
    if (dir_path / "Pulumi.yaml").exists():
        try:
            render_template(
                dir_path / "Pulumi.yaml",
                abs_build_path / "Pulumi.yaml",
                config,
                verbose
            )
            print(f"{Fore.GREEN}Rendered Pulumi.yaml template{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.YELLOW}Error rendering template: {str(e)}. Trying direct copy.{Style.RESET_ALL}")
            try:
                shutil.copy2(dir_path / "Pulumi.yaml", abs_build_path / "Pulumi.yaml")
                print(f"Copied Pulumi.yaml (unprocessed)")
            except Exception as copy_error:
                print(f"{Fore.RED}Failed to copy Pulumi.yaml: {str(copy_error)}{Style.RESET_ALL}")
    
    try:
        # Login to Pulumi backend
        if verbose:
            print(f"{Fore.CYAN}Logging in to Pulumi backend...{Style.RESET_ALL}")
        
        login_attempts = [
            ["pulumi", "login", "file://~", "--local"],
            ["pulumi", "login", "file://", "--local"],
            ["pulumi", "login", "file://~"],
            ["pulumi", "login", "file://"],
            ["pulumi", "login", "--local"]
        ]
        
        login_success = False
        for login_cmd in login_attempts:
            try:
                if verbose:
                    print(f"Attempting login with: {' '.join(login_cmd)}")
                
                result = subprocess.run(
                    login_cmd,
                    cwd=str(abs_build_path),
                    env=env,
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    login_success = True
                    print(f"{Fore.GREEN}Login successful{Style.RESET_ALL}")
                    break
                elif verbose:
                    print(f"{Fore.YELLOW}Login attempt failed{Style.RESET_ALL}")
            except Exception as e:
                if verbose:
                    print(f"{Fore.YELLOW}Login exception: {str(e)}{Style.RESET_ALL}")
        
        if not login_success:
            print(f"{Fore.RED}Failed to login to Pulumi. Cannot generate graph.{Style.RESET_ALL}")
            return
            
        # Check if stack exists
        try:
            if verbose:
                print(f"Checking if stack '{config.stack_name}' exists...")
            
            stack_ls_result = subprocess.run(
                ["pulumi", "stack", "ls"],
                cwd=str(abs_build_path),
                env=env,
                capture_output=True,
                text=True
            )
            
            stack_exists = False
            if stack_ls_result.returncode == 0:
                # Parse the output to look specifically for our stack
                lines = stack_ls_result.stdout.strip().split('\n')
                for line in lines:
                    if config.stack_name in line:
                        stack_exists = True
                        if verbose:
                            print(f"{Fore.GREEN}Found stack: {line.strip()}{Style.RESET_ALL}")
                        break
            
            if not stack_exists:
                print(f"{Fore.RED}Stack '{config.stack_name}' not found. Cannot generate graph.{Style.RESET_ALL}")
                return
                
        except Exception as e:
            print(f"{Fore.RED}Error checking for stack: {str(e)}{Style.RESET_ALL}")
            return
        
        # Select stack
        select_result = subprocess.run(
            ["pulumi", "stack", "select", config.stack_name],
            cwd=str(abs_build_path),
            env=env,
            capture_output=True,
            text=True
        )
        
        if select_result.returncode != 0:
            print(f"{Fore.RED}Failed to select stack '{config.stack_name}'. Error: {select_result.stderr.strip()}{Style.RESET_ALL}")
            return
        
        print(f"{Fore.CYAN}Generating resource dependency graph for stack '{config.stack_name}'...{Style.RESET_ALL}")
        
        # Get resource details if requested
        resources = []
        if resource_details or tree_view or pretty_print:
            resources = get_stack_resources(abs_build_path, config.stack_name, env)
            if verbose and resources:
                print(f"{Fore.GREEN}Retrieved details for {len(resources)} resources{Style.RESET_ALL}")
        
        # Create a temporary file for the graph output
        fd, temp_path = tempfile.mkstemp(suffix='.dot')
        os.close(fd)
        temp_file = Path(temp_path)
        
        # Generate the graph to the temporary file
        graph_cmd = ["pulumi", "stack", "graph", str(temp_file), "--stack", config.stack_name]
        
        result = subprocess.run(
            graph_cmd,
            cwd=str(abs_build_path),
            env=env,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"{Fore.RED}Failed to generate graph. Error: {result.stderr.strip() if result.stderr else 'Unknown error'}{Style.RESET_ALL}")
            # Clean up temporary file
            try:
                temp_file.unlink()
            except Exception:
                pass
            return
            
        # Read the DOT file
        try:
            with open(temp_file, 'r') as f:
                dot_content = f.read()
        except Exception as read_error:
            print(f"{Fore.RED}Error reading graph: {str(read_error)}{Style.RESET_ALL}")
            return
        
        # Handle output
        if save_to_file:
            # Copy the graph to the requested output file
            try:
                shutil.copy2(temp_file, save_to_file)
                print(f"{Fore.GREEN}Graph saved to: {save_to_file}{Style.RESET_ALL}")
                
                # Print visualization guidance
                print(f"{Fore.CYAN}To visualize the DOT graph, you can use tools like Graphviz:{Style.RESET_ALL}")
                print(f"  $ dot -Tpng {save_to_file} -o graph.png")
                print(f"  $ dot -Tsvg {save_to_file} -o graph.svg")
            except Exception as copy_error:
                print(f"{Fore.RED}Error saving graph to file: {str(copy_error)}{Style.RESET_ALL}")
        
        # Display as requested format
        if tree_view:
            # Use simplified tree display
            display_simple_tree(dot_content, resources, resource_details, verbose)
        elif pretty_print:
            # Use pretty formatter
            format_dot_output(dot_content)
        elif not save_to_file:
            # Just print the DOT content
            print("\n" + dot_content)
            print(f"\n{Fore.GREEN}Graph generated successfully{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Tip: Use --tree flag for a tree view or --pretty for a formatted view{Style.RESET_ALL}")
        
        # Clean up temporary file
        try:
            temp_file.unlink()
        except Exception:
            pass
            
    except Exception as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        raise

def graph_command(args: Namespace) -> None:
    """Execute the graph command."""
    # Ensure paths are absolute
    abs_work_dir = args.work_dir.absolute()
    abs_build_dir = abs_work_dir / "build"
    
    # Check available flags
    verbose = getattr(args, 'verbose', False)
    tree_view = getattr(args, 'tree', False)
    resource_details = getattr(args, 'details', False)
    pretty_print = getattr(args, 'pretty', False)
    
    # Print paths only in verbose mode
    if verbose:
        print(f"Using work directory: {abs_work_dir}")
        print(f"Using build directory: {abs_build_dir}")
    
    # Ensure build directory exists
    abs_build_dir.mkdir(parents=True, exist_ok=True)
    
    # Create .pulumi directory if it doesn't exist
    pulumi_dir = abs_build_dir / ".pulumi"
    pulumi_dir.mkdir(parents=True, exist_ok=True)
    
    # Set environment variables BEFORE any Pulumi operations
    os.environ["PULUMI_HOME"] = str(pulumi_dir)
    os.environ["PULUMI_CONFIG_PASSPHRASE"] = ""
    os.environ["PULUMI_SKIP_UPDATE_CHECK"] = "true"  # Skip update checks
    
    # Get stack name and create config
    stack_name = get_stack_name(args.stack_name, abs_work_dir)
    config = Config.from_cli(
        stack_name=stack_name,
        project_id=args.project_id,
        proxy_address=args.proxy_address,
        proxy_port=args.proxy_port,
        use_local_auth=args.use_local_auth,
        no_proxy=args.no_proxy,
        staging=args.stg,
        service=args.srv,
    )
    
    setup_proxy(config)
    setup_gcloud(config)
    
    # For extra safety, copy any Pulumi files from work dir to build dir
    for entry in abs_work_dir.glob("Pulumi.*"):
        if entry.is_file():
            target = abs_build_dir / entry.name
            try:
                shutil.copy2(entry, target)
                if verbose:
                    print(f"Copied Pulumi file: {entry.name}")
            except Exception as e:
                if verbose:
                    print(f"Failed to copy {entry.name}: {str(e)}")
    
    # Handle output file
    output_file = None
    if args.output:
        output_file = Path(args.output)
        if not output_file.is_absolute():
            output_file = abs_work_dir / output_file
    
    # Process the directory
    process_pulumi_graph(
        abs_work_dir, 
        abs_build_dir, 
        config, 
        args.format, 
        output_file,
        verbose,
        tree_view,
        resource_details,
        pretty_print
    )import os
import re
import subprocess
import sys  # Added import for sys module
import shutil
from argparse import Namespace
from pathlib import Path

from colorama import Fore, Style

class BLIError(Exception):
    """Custom exception class for BLI errors."""
    pass

def interpret_pulumi_error(error_text: str) -> str:
    """Convert Pulumi errors into BLI-specific error messages."""
    # Map of regex patterns to user-friendly messages
    error_mappings = [
        # Login errors
        (r"error: could not unmarshal.*Configuration key '(.+)' is not namespaced", 
         "Invalid configuration in Pulumi.yaml. Configuration keys must be properly namespaced."),
        (r"error: no stack selected", 
         "No Pulumi stack is selected. Run 'bli init -s <stack-name>' to create and select a stack."),
        (r"error: could not log in.*", 
         "Failed to log in to Pulumi backend. Check your network connection and Pulumi CLI installation."),
        # Stack errors
        (r"error: stack '(.+)' already exists", 
         "Stack already exists. Use a different stack name or run commands on the existing stack."),
        (r"error: failed to create stack: (.+)", 
         "Stack creation failed. Make sure you have the right permissions and valid stack name."),
        # General errors
        (r"error: no project file found in", 
         "No Pulumi project found in the current directory. Run 'bli init' first."),
        (r"error: failed to load project: (.+)", 
         "Failed to load Pulumi project. Check your Pulumi.yaml file for errors."),
    ]
    
    # Try to match the error text to a pattern
    for pattern, message in error_mappings:
        match = re.search(pattern, error_text)
        if match:
            return message
    
    # Default message if no specific pattern matches
    return f"Pulumi error: {error_text}"

def run_pulumi_command(command: list, cwd: str, suppress_output: bool = False) -> subprocess.CompletedProcess:
    """Run a Pulumi command with better error handling."""
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            capture_output=True,
            text=True,
            check=True
        )
        if not suppress_output and result.stdout.strip():
            print(result.stdout.strip())
        return result
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr.strip() if hasattr(e, 'stderr') and e.stderr else str(e)
        user_friendly_error = interpret_pulumi_error(error_msg)
        
        raise BLIError(f"{user_friendly_error}\n\nCommand: {' '.join(command)}")

def initialize_pulumi_stack(work_dir: Path, stack_name: str) -> None:
    """Initialize a new Pulumi stack using YAML format."""
    print(f"Initializing Pulumi stack in: {work_dir}")
    
    # Get absolute path
    abs_work_dir = work_dir.absolute()
    
    # Create directory if it doesn't exist
    abs_work_dir.mkdir(parents=True, exist_ok=True)
    
    # First, check if there's any existing Pulumi.yaml and rename it temporarily
    pulumi_yaml_path = abs_work_dir / "Pulumi.yaml"
    temp_backup = None
    
    if pulumi_yaml_path.exists():
        temp_backup = abs_work_dir / "Pulumi.yaml.backup"
        pulumi_yaml_path.rename(temp_backup)
        print(f"{Fore.YELLOW}Found existing Pulumi.yaml, temporarily backed up to {temp_backup}{Style.RESET_ALL}")
    
    try:
        # Try to login to the local file-based backend
        print("Logging in to Pulumi backend...")
        result = subprocess.run(
            ["pulumi", "login", "file://~", "--non-interactive"],
            cwd=str(abs_work_dir),
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"{Fore.RED}Login failed with error: {result.stderr.strip()}{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Trying alternative login approach...{Style.RESET_ALL}")
            
            # Try alternative approach - use file:// without the ~
            result = subprocess.run(
                ["pulumi", "login", "file://", "--non-interactive"],
                cwd=str(abs_work_dir),
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                raise Exception(f"Failed to login to Pulumi backend: {result.stderr.strip()}")
        
        print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Successfully logged in to Pulumi backend")
        
        # Now create the Pulumi.yaml file
        project_name = stack_name.replace('-', '_').lower()
        pulumi_yaml_content = f"""name: {project_name}
runtime: yaml
description: A Pulumi project created with BLI

variables:
  projectName:
    fn::invoke:
      function: pulumi:getProject
  stackName:
    fn::invoke:
      function: pulumi:getStack

resources:
  # Example resource (commented out)
  # my-bucket:
  #   type: gcp:storage:Bucket
  #   properties:
  #     location: US

outputs:
  message: "Stack initialized successfully!"
"""
        pulumi_yaml_path.write_text(pulumi_yaml_content)
        print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Created Pulumi.yaml with project name: {project_name}")
        
        # Create a new stack
        print(f"Creating new stack: {stack_name}...")
        stack_result = subprocess.run(
            ["pulumi", "stack", "init", stack_name, "--non-interactive"],
            cwd=str(abs_work_dir),
            capture_output=True,
            text=True
        )
        
        if stack_result.returncode != 0:
            if "already exists" in stack_result.stderr:
                print(f"{Fore.YELLOW}Stack '{stack_name}' already exists. Selecting it...{Style.RESET_ALL}")
                select_result = subprocess.run(
                    ["pulumi", "stack", "select", stack_name],
                    cwd=str(abs_work_dir),
                    capture_output=True,
                    text=True
                )
                if select_result.returncode != 0:
                    raise Exception(f"Failed to select stack: {select_result.stderr.strip()}")
                print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Selected stack: {stack_name}")
            else:
                raise Exception(f"Failed to create stack: {stack_result.stderr.strip()}")
        else:
            print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Created stack: {stack_name}")
        
        # Create a stack configuration file if it doesn't exist
        stack_yaml_path = abs_work_dir / f"Pulumi.{stack_name}.yaml"
        if not stack_yaml_path.exists():
            stack_yaml_content = """# Stack-specific configuration
config:
  # Example for GCP project (uncomment and modify as needed)
  # gcp:project: my-gcp-project-id
  # gcp:region: us-central1
"""
            stack_yaml_path.write_text(stack_yaml_content)
            print(f"{Fore.GREEN}âœ“{Style.RESET_ALL} Created stack configuration file: Pulumi.{stack_name}.yaml")
            
        print(f"{Fore.GREEN}Stack '{stack_name}' is ready to use!{Style.RESET_ALL}")
        
    except Exception as e:
        print(f"{Fore.RED}Error initializing stack: {str(e)}{Style.RESET_ALL}")
        
        # Restore backup if it exists
        if temp_backup and temp_backup.exists():
            temp_backup.rename(pulumi_yaml_path)
            print(f"{Fore.YELLOW}Restored original Pulumi.yaml from backup{Style.RESET_ALL}")
        
        raise

def init_command(args: Namespace) -> None:
    """Execute the init command."""
    try:
        initialize_pulumi_stack(args.work_dir, args.stack_name)
    except BLIError as e:
        print(f"{Fore.RED}Error: {str(e)}{Style.RESET_ALL}")
        # Provide helpful suggestions
        print(f"\n{Fore.YELLOW}Troubleshooting tips:{Style.RESET_ALL}")
        print("1. Ensure you have the latest version of Pulumi CLI installed")
        print("2. Try with a different stack name")
        print("3. Check permissions in your home directory")
        print("4. Run 'bli depend' to verify dependencies are correctly installed")
        sys.exit(1)
    except Exception as e:
        print(f"{Fore.RED}Unexpected error: {str(e)}{Style.RESET_ALL}")
        # For unexpected errors, suggest reporting the issue
        print(f"\n{Fore.YELLOW}This appears to be an unexpected error. Please report this issue.{Style.RESET_ALL}")
        sys.exit(1)from bli.cli import main

if __name__ == "__main__":
    main()from setuptools import setup, find_packages

# Read the long description from README.md
try:
    with open("README.md", "r", encoding="utf-8") as fh:
        long_description = fh.read()
except FileNotFoundError:
    long_description = "BLI CLI - A Pulumi-based Infrastructure Management Tool"

setup(
    name="bli",
    version="0.1.0",
    
    # Metadata
    author="terekete",
    author_email="gates.mark@gmail.com",
    description="BLI CLI - A Pulumi-based Infrastructure Management Tool",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/bli",
    
    # Packaging
    packages=find_packages(),
    
    # Python version and platform support
    python_requires='>=3.7,<4.0',
    
    # Dependencies
    install_requires=[
        "pulumi>=3.0.0,<4.0.0",
        "jinja2>=3.0.0,<4.0.0",
        "colorama>=0.4.4,<1.0.0",
    ],
    
    # Optional dependencies (extras)
    extras_require={
        'dev': [
            'pytest>=6.2.0',
            'tox>=3.24.0',
            'mypy>=0.910',
            'black>=21.5b2',
        ],
        'docs': [
            'sphinx>=4.0.0',
            'sphinx-rtd-theme>=0.5.2',
        ],
    },
    
    # Entry points for CLI
    entry_points={
        "console_scripts": [
            "bli=bli.cli:main",
        ],
    },
    
    # Metadata for PyPI
    classifiers=[
        # Development Status
        "Development Status :: 3 - Alpha",
        
        # Intended Audience
        "Intended Audience :: Developers",
        "Intended Audience :: System Administrators",
        
        # License
        "License :: OSI Approved :: MIT License",
        
        # Operating System
        "Operating System :: OS Independent",
        
        # Python Versions
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        
        # Categories
        "Topic :: Software Development :: Build Tools",
        "Topic :: System :: Systems Administration",
        "Topic :: Utilities",
    ],
    
    # Package data (include non-Python files)
    package_data={
        "bli": ["*.yaml", "*.yml"],
    },
    
    # Keyword tags for discoverability
    keywords="infrastructure pulumi cli devops deployment automation gcp",
)